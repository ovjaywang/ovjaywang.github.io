<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ov智商捉急</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ovjaywang.github.io/"/>
  <updated>2018-01-28T05:32:56.733Z</updated>
  <id>http://ovjaywang.github.io/</id>
  
  <author>
    <name>Jay Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>沙扬娜拉</title>
    <link href="http://ovjaywang.github.io/2017/04/21/%E6%B2%99%E6%89%AC%E5%A8%9C%E6%8B%89/"/>
    <id>http://ovjaywang.github.io/2017/04/21/沙扬娜拉/</id>
    <published>2017-04-21T08:01:33.000Z</published>
    <updated>2018-01-28T05:32:56.733Z</updated>
    
    <content type="html">&lt;p&gt;哎我萨该彻底重建了吧。白白明年见      &lt;/p&gt;
&lt;p&gt;.me域名到期 穷狗续费无力。继续一年一换的风格转战mimimomo.asia 看起来高大上     &lt;/p&gt;
&lt;p&gt;该和学校说再见了。认真对待好下面这写日子吧。这个季节少了很多烟酒茶或许真的是老了&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;哎我萨该彻底重建了吧。白白明年见      &lt;/p&gt;
&lt;p&gt;.me域名到期 穷狗续费无力。继续一年一换的风格转战mimimomo.asia 看起来高大上     &lt;/p&gt;
&lt;p&gt;该和学校说再见了。认真对待好下面这写日子吧。这个季节少了很多烟酒茶或许真的是老了&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习要点检索--基于图解机器学习</title>
    <link href="http://ovjaywang.github.io/2017/02/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A6%81%E7%82%B9%E6%A3%80%E7%B4%A2/"/>
    <id>http://ovjaywang.github.io/2017/02/27/机器学习要点检索/</id>
    <published>2017-02-27T08:54:19.000Z</published>
    <updated>2018-01-28T05:32:56.733Z</updated>
    
    <content type="html">&lt;p&gt;这是一个机器学习知识记录贴，主要内容是Ng的ML课、《图解机器学习》、《机器学习》周志华版。懒癌发作了可能就不更了&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;机器学习任务&quot;&gt;&lt;a href=&quot;#机器学习任务&quot; class=&quot;headerlink&quot; title=&quot;机器学习任务&quot;&gt;&lt;/a&gt;机器学习任务&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;判别式（识别式）学习&lt;/strong&gt;：通过预测数据生成对联合概率&lt;strong&gt;p(x,y)&lt;/strong&gt;进行模式识别的方法·&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产生式学习&lt;/strong&gt;：利用机器学习方法对训练集&lt;strong&gt;p(y|x)&lt;/strong&gt;进行学习的过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可能有拥有足够的信息来很好的解决一个感兴趣的特定问题，但却没有足够的信息来解决一个一般性问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;如果生成概率已知，则可以推出后验概率（所有y可能性的联合概率加和计算x的概率）；反之，则不能。&lt;/p&gt;
&lt;p&gt;$$p(y\mid x)=\frac{p(x,y)}{p(x)}=\frac{p(x,y)}{\sum _{y}p(x,y)}$$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;统计派（频率派）&lt;/strong&gt;：将模式θ(模型参数)作为决定论的变量，使用训练样本${(x_{i},y_{i})}_{i=1}^{n}$对Θ进行学习。(e.g.利用最大似然π)      &lt;/p&gt;
&lt;p&gt;其主要&lt;strong&gt;研究课题&lt;/strong&gt;是如何有训练集得到高精度的模式Θ。      &lt;/p&gt;
&lt;p&gt;$$\underset{\theta}{max}\prod_{i=1}^{y}q(x_{i},y_{i},\theta )$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;贝叶斯派&lt;/strong&gt; ：将模式Θ作为概率变量，对其先验概率p(Θ)加以考虑，计算与训练集相对应的后验概率p(Θ|D).并利用贝叶斯公式求解后验概率&lt;/p&gt;
&lt;p&gt;$$p(\theta \mid D)=\frac{p(D\mid \theta )p(\theta )}{p(D)}=\frac{\prod_{i=1}^{n}q(x_{i},y_{i}\mid \theta )p(\theta )}{\int \prod_{i=1}^{n}q(x_{i},y_{y}|\theta )p(\theta )d\theta }$$&lt;/p&gt;
&lt;p&gt;贝叶斯学派的&lt;strong&gt;主要任务&lt;/strong&gt;是如何通过各种方式精确计算后验概率。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt; 只在训练集的输入样本附近对函数进行近似，可以减轻维数灾难的影响&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;学习模型&quot;&gt;&lt;a href=&quot;#学习模型&quot; class=&quot;headerlink&quot; title=&quot;学习模型&quot;&gt;&lt;/a&gt;学习模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;线性模型&lt;/strong&gt;–典型的代表是$$f_{\theta}(x)=\theta_{1}x+\theta_{0}$$对面积-房价进行一元一次线性拟合&lt;/p&gt;
&lt;p&gt;标准形式为：$f_{\theta }(x)=\sum_{j=1}^{b}\theta_{j}\phi_{j}(x)=\theta ^{\top }\phi (x)$,其中$\theta_{j}$是参数向量（待解求的参数集合）$\theta=(\theta_{1},\theta_{2}…\theta_{b})^{\top }$的第j个因子；$\phi_{j}(x)$ 是基函数（决定了拟合的模式 以特征为基础可以自由决定衍生的多项式、函数模式$ln x$、$\frac{1}{x}$等，一般来说都是多项式，即$\phi_{j}(x)=(1,x,x^2…x^{b-1})^{\top }$;又或者是三角多项式形式，即$\phi_{j}(x)=(1,sin x,cos x,sin 2x,cos 2x…sin mx,cos mx)^{\top }$）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当不止考虑一个维度的因素（特征）时，输入维度太多易造成维度爆炸。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;核模型&lt;/strong&gt;–典型代表四高斯核&lt;/p&gt;
&lt;p&gt;$$K(x,c)=e^{-\frac{\left | x-c \right |^2}{2h^2}}$$&lt;/p&gt;
&lt;p&gt;可理解为欧几里得空间映射到核函数空间中，在函数设计时可以依赖样本$$\{(x_{i},y_{i})\}_{i=1}^{n}$$。式中，h和c分别是带宽和均值。高斯核模型一般只能对样本附近的函数进行近似.&lt;/p&gt;
&lt;p&gt;标准形式为：$f_{\theta}(x)=\sum_{j=1}^{n}\theta_{j}K(x,x_j)$ 其中$K(x,x_j)$是二元核函数，以线性相加所有样本的方式定义。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参数的个数不依赖于输入变量的维度d，而只有训练样本的数量m决定。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;层级模型&lt;/strong&gt;–典型代表是神经网络,尤其是不完全映射的神经网络.&lt;/p&gt;
&lt;p&gt;标准形式为:$f_{\theta}(x)=\sum_{j=1}^{b}\alpha _{j}\phi (x;\beta _{j})$  其中$\phi (x;\beta _{j})$是带有参数向量β的基函数。即，整个模型的参数为$\theta=(\alpha ,\beta _{1}^\top ,…,\beta _{b}^\top )^\top $其中，α是层次模型线性形式的参数向量。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的层级模型是卷积和神经网络。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;最小二乘法&quot;&gt;&lt;a href=&quot;#最小二乘法&quot; class=&quot;headerlink&quot; title=&quot;最小二乘法&quot;&gt;&lt;/a&gt;最小二乘法&lt;/h1&gt;&lt;p&gt;入门的入门就是最小二乘了，类似二范数，目标是最小化所有样本与其预测值差的平方和：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敲黑板&lt;/strong&gt;，上边表达的就是代价函数，即下式：&lt;/p&gt;
&lt;p&gt;$$J_{LS}(\theta )=\frac{1}{2}\sum_{i=1}^{n}(f_{\theta }(x_{i})-y_{i})^2$$&lt;/p&gt;
&lt;p&gt;其中，i是具体样本编号，n是样本个数，LS即least square最小二乘。&lt;/p&gt;
&lt;p&gt;解求目标是：&lt;/p&gt;
&lt;p&gt;$$\widehat{\theta_{LS}}=\underset{\theta }{argmin}J_{LS}(\theta )$$&lt;/p&gt;
&lt;p&gt;其中$\widehat{\theta_{LS}}$表达对参数的预测值。再次&lt;strong&gt;敲黑板&lt;/strong&gt;，这句话包含很多意思&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以最小二乘法表达代价函数，解算的目标是：当代价函数求得最小的时候参数$\theta$的值&lt;/li&gt;
&lt;li&gt;代价函数的最小值是多少我不关心，我只关心代价函数求得最小时参数向量的值是多少–即解求的目标不是函数的最值，是函数的极值点。&lt;/li&gt;
&lt;li&gt;常用在线性函数最值的求解，配合&lt;strong&gt;SVD&lt;/strong&gt;(范式函数)或&lt;strong&gt;梯度下降法&lt;/strong&gt;解求$\theta$的值 两者的内涵是一致的&lt;/li&gt;
&lt;li&gt;需提前大致知道样本的模式(即基函数的确定，对多项式来说是最高几次？对三角函数式来说是基函数的振幅和频率的确定——基函数次数过高或项数过多易造成过拟合&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;正态方程解法-Normal-Equation&quot;&gt;&lt;a href=&quot;#正态方程解法-Normal-Equation&quot; class=&quot;headerlink&quot; title=&quot;正态方程解法(Normal Equation)&quot;&gt;&lt;/a&gt;正态方程解法(Normal Equation)&lt;/h2&gt;&lt;p&gt;对于解求一元函数，窝们知道应该对函数求导求取零值点；而对于向量（可视为多元函数），求取各参量的偏导求解零值亦可求取极值。对广义线性模式的预测函数&lt;/p&gt;
&lt;p&gt;$$f_{\theta }(x_{j})=\theta_{b-1}x^{b-1}_{j}+…+\theta_{2}x^{2}_{j}+\theta_{1}x_{j}+\theta_{0}x_{j}=\Theta ^{\top }\phi (x)$$&lt;/p&gt;
&lt;p&gt;来说，参数的偏导形式为：&lt;/p&gt;
&lt;p&gt;$$\bigtriangledown_{\theta}J_{LS}=\frac{\partial J_{LS}}{\partial \theta }=\frac{1}{2}\cdot 2\cdot\Phi ^{\top }(\Phi \Theta -y)=\Phi^{\top }\Phi \Theta ^{\top }-\Phi ^{\top}y$$&lt;/p&gt;
&lt;p&gt;其中，$\Phi $为基函数与样本点组成的n×b矩阵，&lt;/p&gt;
&lt;p&gt;$$\Phi =\begin{pmatrix}&lt;br&gt;\phi_{1}(x_{1}) &amp;amp;\cdots   &amp;amp; \phi_{b}(x_1)\\&lt;br&gt;\vdots &amp;amp; \ddots  &amp;amp; \vdots \\&lt;br&gt;\phi_{1}(x_n) &amp;amp;\cdots &amp;amp; \phi _{b}(x_{n})&lt;br&gt;\end{pmatrix}$$&lt;/p&gt;
&lt;p&gt;$\Theta$为b ×1 维参数向量参数向量。令偏导为0即可解求参数向量$\theta$的具体值：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$$\widehat{\theta _{LS}}=(\Phi^{\top }\Phi)^{-1} \Phi^{\top }y$$&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上式对广义线性模式的基函数与参数向量的组合均适用。式中的矩阵逆运算，可通过&lt;strong&gt;SVD&lt;/strong&gt;分解求得，因而如果样本过多（m值过大），维度过大(n值过大)，则复杂度较高，计算消耗较大（O(n^3)的复杂度）。&lt;/p&gt;
&lt;p&gt;若换用核模型，$$f_{\theta}(x)=\sum_{j=1}^{n}\theta _{j}K(x,x_j)$$,可认为直接把$\Phi$替换定义的核矩阵，即可求得核模型的最小二乘解。上式$\Phi$可替换为&lt;/p&gt;
&lt;p&gt;$$\kappa = \begin{pmatrix}&lt;/p&gt;
&lt;p&gt;K(x_{1},x_{1}) &amp;amp;\cdots   &amp;amp; K(x_{1},x_{n})\\\\&lt;/p&gt;
&lt;p&gt;\vdots &amp;amp; \ddots  &amp;amp; \vdots \\\\&lt;/p&gt;
&lt;p&gt;K(x_n,x_1) &amp;amp;\cdots &amp;amp; K(x_{n},x_{n})&lt;/p&gt;
&lt;p&gt;\end{pmatrix}$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意notes&lt;/strong&gt;  当矩阵不可逆，及其可能两个特征过于&lt;strong&gt;接近&lt;/strong&gt;或特征过少样本过多&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;最小二乘法输出的预测值时由$    \Re(\Phi )$的正摄投影得到。其中，$\Re$表达$\Phi$的值域，$\Phi$是上式基函数矩阵与具体样本构成的n×b矩阵&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;梯度下降解法&quot;&gt;&lt;a href=&quot;#梯度下降解法&quot; class=&quot;headerlink&quot; title=&quot;梯度下降解法&quot;&gt;&lt;/a&gt;梯度下降解法&lt;/h2&gt;&lt;p&gt;  ​&lt;/p&gt;
&lt;h3 id=&quot;梯度下降基本原理&quot;&gt;&lt;a href=&quot;#梯度下降基本原理&quot; class=&quot;headerlink&quot; title=&quot;梯度下降基本原理&quot;&gt;&lt;/a&gt;梯度下降基本原理&lt;/h3&gt;&lt;p&gt;计算线性回归时，为了更快收敛更节省计算资源，设计&lt;strong&gt;梯度下降法&lt;/strong&gt;——给定某个初值，以一定的&lt;strong&gt;步长α&lt;/strong&gt;（学习率）向&lt;strong&gt;梯度的方向&lt;/strong&gt;（函数向局部极小值 下降最快的方向）趋近迭代的算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该方式主要针对线性空间凸函数，即有可求极值点&lt;/li&gt;
&lt;li&gt;该方法需要同时更新所有的参数向量，计算本次 参数向量统一使用上一次的数据&lt;/li&gt;
&lt;li&gt;设置合理的阈值能更快收敛&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对向量参数$\theta$的每个具体参数，其迭代的方式为：$$\theta_{j}  += \theta_{j} - \alpha \frac{\partial }{\partial \theta _{j}}J_{LS}(\theta )$$&lt;/p&gt;
&lt;p&gt;其中α是&lt;strong&gt;学习率&lt;/strong&gt;，后边一坨是&lt;strong&gt;代价函数对具体参数向量的偏导&lt;/strong&gt;。学习率决定了趋近的速率，过小迭代次数过多收敛过慢，过大易造成远离极值点。对假设模型为线性函数形如上式$f_{\theta }(x_{j})=\theta_{b-1}x^{b-1}_{j}+…+\theta_{2}x^{2}_{j}+\theta_{1}x_{j}+\theta_{0}x_{j}=\Theta ^{\top }\phi (x)$的导数，将向量θ视为一个参数，其代价函数J(θ)对θ导数：&lt;/p&gt;
&lt;p&gt;$$ \frac{\partial }{\partial \theta }\frac{1}{2}(f_{\Theta }(X)-Y)^2=2\cdot \frac{1}{2}\cdot(h_{\theta}(X)-Y)\sum_{j=0}^{n}\frac{\partial }{\partial \theta _j}(\sum_{i=0}^{n}\theta _{i}x_{i}-Y)=\sum_{j=0}^{n}(h_{\theta}(X)-Y)x_j= (h_{\theta}(X)-Y)X$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;其中j是参数向量某个具体位置，而$x_j$是其对应位置的基函数的值而非样本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$\phi$是基函数，$X$ Y分别是样本向量$X=\{x_1,x_2,…x_m\}$和样本结果实际值向量$Y=\{y_1,y_2…y_m\}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;i是基函数数量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举个栗子。更多的时候，以所有样本的形式列出参数向量更新的过程。当假设基函数为$\phi(x)={(x,1)}$即$f(x)=\theta_1x+\theta_0$其迭代时具体值为：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$\theta_0 += \theta_0 - \alpha\frac{1}{m}\sum_{m}^{i=1}(h_{\theta}(x_i)-y_i)$$&lt;/p&gt;
&lt;p&gt;$$\theta_1 += \theta_1 - \alpha\frac{1}{m}\sum_{m}^{i=1}((h_{\theta}(x_i)-y_i)x_i)$$&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;梯度下降中的约束问题&quot;&gt;&lt;a href=&quot;#梯度下降中的约束问题&quot; class=&quot;headerlink&quot; title=&quot;梯度下降中的约束问题&quot;&gt;&lt;/a&gt;梯度下降中的约束问题&lt;/h3&gt;&lt;p&gt;很多时候，参数并非分布在整个空间域中，而是以一定先验可知的方式存在。例如对于双参数模型，其可能只在一条直线上；对于更多维的特征，其可能存在于一个超球范围内。对于参数的约束可以更好的防止过拟合、更快的进行迭代。以下两种是常见的参数条件约束&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;梯度下降注意事项&quot;&gt;&lt;a href=&quot;#梯度下降注意事项&quot; class=&quot;headerlink&quot; title=&quot;梯度下降注意事项&quot;&gt;&lt;/a&gt;梯度下降注意事项&lt;/h3&gt;&lt;p&gt;梯度下降主要由三种更新方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以最最基本的梯度下降原理，每一次带入&lt;strong&gt;所有&lt;/strong&gt;的样本数据解求更新偏导数-batch批量梯度下降&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据量过多，每次&lt;strong&gt;随机&lt;/strong&gt;抽一个带入解算偏导数，则上式解算每个偏导的函数变为&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$666$$–随机梯度下降&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结合以上两种方式，每次迭代抽取&lt;strong&gt;一小波&lt;/strong&gt;样本更新偏导数–mini-batch 随机批量梯度下降&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说，梯度下降为了保证计算效率和迭代效率，选择第三种比较划算。      &lt;/p&gt;
&lt;p&gt;  ​      &lt;/p&gt;
&lt;p&gt;梯度下降中，选择&lt;strong&gt;合适的α&lt;/strong&gt;比较重要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过小导致收敛过慢&lt;/li&gt;
&lt;li&gt;过大可能无法收敛或越出该局部最小值&lt;/li&gt;
&lt;li&gt;需要对多个α进行测试–出现代价函数增大应减小学习率；若迭代收敛过慢则增大学习率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选择合适的特征尺度也利于收敛。一般而言，可以选择正则化以保证收敛时的计算更为&lt;strong&gt;顺滑精确&lt;/strong&gt;(梯度平缓步长合适)。&lt;strong&gt;注意&lt;/strong&gt;：特征尺度不能解决设计矩阵不可逆、J(θ)不收敛等问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;梯度下降和正态方程比较&quot;&gt;&lt;a href=&quot;#梯度下降和正态方程比较&quot; class=&quot;headerlink&quot; title=&quot;梯度下降和正态方程比较&quot;&gt;&lt;/a&gt;梯度下降和正态方程比较&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Gradient Descent&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;NORmal Equation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;需要选择α&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;需要迭代计算&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;需要计算逆矩阵&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✘&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;当维度n和样本m过大时计算顺利&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✔&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;✘&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&quot;有约束的线性回归&quot;&gt;&lt;a href=&quot;#有约束的线性回归&quot; class=&quot;headerlink&quot; title=&quot;有约束的线性回归&quot;&gt;&lt;/a&gt;有约束的线性回归&lt;/h1&gt;&lt;p&gt;众所周知的是。。线性回归容易过拟合。有效防止过拟合可以采用对参数向量θ进行空间限制。一般而言，θ是R(n+1)空间的任意一个超维空间点，可将其限制在一条超维直线、平面或超球中。&lt;/p&gt;
&lt;h2 id=&quot;限制在空间域的直线上&quot;&gt;&lt;a href=&quot;#限制在空间域的直线上&quot; class=&quot;headerlink&quot; title=&quot;限制在空间域的直线上&quot;&gt;&lt;/a&gt;限制在空间域的直线上&lt;/h2&gt;&lt;h1 id=&quot;Logistics回归（逻辑回归）&quot;&gt;&lt;a href=&quot;#Logistics回归（逻辑回归）&quot; class=&quot;headerlink&quot; title=&quot;Logistics回归（逻辑回归）&quot;&gt;&lt;/a&gt;Logistics回归（逻辑回归）&lt;/h1&gt;&lt;h2 id=&quot;这是一个分类算法&quot;&gt;&lt;a href=&quot;#这是一个分类算法&quot; class=&quot;headerlink&quot; title=&quot;这是一个分类算法&quot;&gt;&lt;/a&gt;&lt;strong&gt;这是一个分类算法&lt;/strong&gt;&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个机器学习知识记录贴，主要内容是Ng的ML课、《图解机器学习》、《机器学习》周志华版。懒癌发作了可能就不更了&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UEFI双系统小记</title>
    <link href="http://ovjaywang.github.io/2017/02/20/UEFI%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%B0%8F%E8%AE%B0/"/>
    <id>http://ovjaywang.github.io/2017/02/20/UEFI双系统小记/</id>
    <published>2017-02-20T15:44:55.000Z</published>
    <updated>2018-01-28T05:32:56.732Z</updated>
    
    <content type="html">&lt;p&gt;喷血了。一个小误会居然装了一个晚上。作为一个6年前就装过双系统的薛薇有些池乳。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;正题&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;一些不会犯的错&quot;&gt;&lt;a href=&quot;#一些不会犯的错&quot; class=&quot;headerlink&quot; title=&quot;一些不会犯的错&quot;&gt;&lt;/a&gt;一些不会犯的错&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;安装的时候不要选双系统也不要选抹掉原系统啊。。不然哪来的双系统&lt;/li&gt;
&lt;li&gt;分区确定好后记得把引导装在boot里面。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一些可能犯的错误&quot;&gt;&lt;a href=&quot;#一些可能犯的错误&quot; class=&quot;headerlink&quot; title=&quot;一些可能犯的错误&quot;&gt;&lt;/a&gt;一些可能犯的错误&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;这次居然遇到了。。分区按别的教程给boot5120M。。居然不够？？最终提示无足够空间&lt;/li&gt;
&lt;li&gt;一般的分区4个都不要少就好了-/ /boot swap /home(/usr也行)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;UEFI下的双系统&quot;&gt;&lt;a href=&quot;#UEFI下的双系统&quot; class=&quot;headerlink&quot; title=&quot;UEFI下的双系统&quot;&gt;&lt;/a&gt;UEFI下的双系统&lt;/h1&gt;&lt;p&gt;按照这两个来就相当好办了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lyhdream/article/details/52266523&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;a href=&quot;http://blog.csdn.net/lyhdream/article/details/52266523&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UEFI引导的系统下装双系统解决方案&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://weibo.com/p/1001603968287473010231?from=page_100606_profile&amp;amp;wvr=6&amp;amp;mod=wenzhangmod&amp;amp;sudaref=www.google.com&amp;amp;retcode=6102&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UEFI模式下安装Windows 10、Ubuntu 16.04 LTS双系统教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前的系统全是在mbr上安的，按照以往是吧iso里的几个文件解压出来放在c盘里，使用easybcd添加引导安装，再自动搜索添加Shaun该系统启动目录，双系统的引导直接放在win下。现在uefi的引导专门搞了一个盘来放置引导和乱七八糟的恢复文件。使用开源的uefi修改器相当顺滑。&lt;/p&gt;
&lt;p&gt;TensorFlow1.0搞起。&lt;/p&gt;
&lt;p&gt;然后发现了一个相当顺滑的hexo同步&lt;a href=&quot;https://www.zhihu.com/question/21193762/answer/147374293&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;方案&lt;/a&gt;。不用更新完一次用一次git命令和hexo命令了。vps必须要摆在日程里了。自动化服务器方案是以后记录笔记、更新博客、抄段子的必备手段了。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;喷血了。一个小误会居然装了一个晚上。作为一个6年前就装过双系统的薛薇有些池乳。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2016回想</title>
    <link href="http://ovjaywang.github.io/2017/01/18/2016%E5%9B%9E%E6%83%B3/"/>
    <id>http://ovjaywang.github.io/2017/01/18/2016回想/</id>
    <published>2017-01-17T16:45:36.000Z</published>
    <updated>2017-01-17T17:08:05.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;说说去年的成长&quot;&gt;&lt;a href=&quot;#说说去年的成长&quot; class=&quot;headerlink&quot; title=&quot;说说去年的成长&quot;&gt;&lt;/a&gt;说说去年的成长&lt;/h1&gt;&lt;p&gt;很忙，也很空虚。做着重复的事情，去了没有效率和收获的地方，跑了好几个空场。但，不得不的是，活在当下吧。暂且算是找了个工作，听大家的，先就业后择业。大家的待遇都比我好，也都比我顺利，事实上也总是如此，不是一下子就这么惨的。使劲的，假装的，学了很多，的确是很多-&gt;机器学习，计算机网络，深度学习，计算机视觉……一股脑没来由的全塞过来，倒是样样没天赋的样子。笔记做了好几本，学过的没学过的，记得快，忘得快。&lt;/p&gt;
&lt;p&gt;晚睡，要改。旷班，要改。拿啥，要改。语塞，要改。作，要改。&lt;/p&gt;
&lt;p&gt;少去了很多次电影院（尽管很多时候更愿意一个人。）更多spare time选择自己自己一个人撸剧撸书；很多没意思的游戏坚持了下来，又探索了一直以来倔强抗拒的moba；也更能花了。努力培养自己的消费习惯，从消费粮食到消费内容，义无反顾的加入中国特色的社会主义文化建设。文章其实很早就有了头绪，但是苦于时间实在是挤不出，囿于有些便利条件，交差的很晚，索性是在有限的条件下，写的比较丰满。&lt;/p&gt;
&lt;p&gt;少喝了很多酒，多吃了很多饭。一直想找个平台分享吃的，可惜没找到。支付宝算半个，可惜人太丰富人格滤镜少了些。葫芦已让我有些神经衰弱，算半个逃避的借口。拿啥算另外半个。&lt;/p&gt;
&lt;p&gt;人格改变了很多，习性却没啥改进。懒惰，拖延，矫情，自负，不解风情……好友仍是那两三个，交际没有拓展，找不到合适的圈子和兴趣，无所事事却又忙的昏天暗地。不知道是什么情况，很久没有联系的小伙伴今年都找了我，猪，ex,开火车的少年，农行狗，交大大神，成都智障儿童。。都能相互关心相互唏嘘，很好。加了很多群，没几个能说的上话。游戏玩了好几个，最喜欢的还是五六年前喜欢的。书买了好几本，最喜欢的还是翻来覆去的时间拣屎。终归也是坚持了一些事情，坚持了特别久，记账和对账，备份分类照片，更新影评和书评。&lt;/p&gt;
&lt;p&gt;学生时代要结束了，科研的生涯也到了尽头。该不该出国，该不该找女票，该不该往技术方向发展，只能慢慢走了。自己的确是个不会做计划，不会组织的人。即便写下豪情万丈的计划，不出一周就要磨灭。总说计划赶不上变化，任何app都救不了。该学习的还有很多，期待一下吧，希望不是个坐吃等死的工作，我还是喜欢激情燃烧的。没人和我去深圳，新的环境新的人，总该收敛一些好，毕竟社会太复杂。&lt;/p&gt;
&lt;p&gt;还有，该健身了。&lt;br&gt;还有，该旅游了。&lt;br&gt;还有，该学习英语和会计了&lt;/p&gt;
&lt;h1 id=&quot;花钱&quot;&gt;&lt;a href=&quot;#花钱&quot; class=&quot;headerlink&quot; title=&quot;花钱&quot;&gt;&lt;/a&gt;花钱&lt;/h1&gt;&lt;p&gt;明明没赚多少，也没涨工资，却花的越来越大手笔了。去年都不敢奢望吃15块以上的外面现在随便一点就上30了。。吃了更多的馆子。上半年是风格和温泉。下半年是小组。但逃不了的是各种鱼和肉。放弃了坚持了很久的跑步和健身，却没胖起来，这让人失望。花了更多的钱去买零食和小吃，门口的小摊的铁板烧，自助机的酸奶，奥金星的咖啡都是常年必备。不得不说微信和支付宝的推广和运营深得我心，撺掇着我去努力消费努力赚优惠和代金券。          &lt;/p&gt;
&lt;p&gt;办了3张信用卡。浦发还多办了张我萨的。决定分门别类以后消费都使用不同的渠道了。光大主吃。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说说去年的成长&quot;&gt;&lt;a href=&quot;#说说去年的成长&quot; class=&quot;headerlink&quot; title=&quot;说说去年的成长&quot;&gt;&lt;/a&gt;说说去年的成长&lt;/h1&gt;&lt;p&gt;很忙，也很空虚。做着重复的事情，去了没有效率和收获的地方，跑了好几个空场。但，不得不的是，活在当下吧
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Learn Sth. the Other Day</title>
    <link href="http://ovjaywang.github.io/2016/08/18/Learn-sth-the-other-day/"/>
    <id>http://ovjaywang.github.io/2016/08/18/Learn-sth-the-other-day/</id>
    <published>2016-08-18T10:58:03.000Z</published>
    <updated>2017-01-17T16:44:28.000Z</updated>
    
    <content type="html">&lt;p&gt;近期忙着撸工作。边学边总结。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;16-11-03&lt;br&gt;蛇精网络中，激活函数一般选择sigmod或者双曲正切函数。即&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;f(x)=\frac{1}{1+e^{-x}}&lt;br&gt;f’(x)=f(x)(1-f(x))&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;f(x)=tanh(x)=\frac{e^{x}-e^{-x}}{e^{x}+e^{-x}}&lt;br&gt;f’(x)=1-(f(x))^{2}&lt;br&gt;$$&lt;br&gt;一个神经元的主要过程有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;综合输入，根据Wx+b计算每个输入的滤波结果（可理解为线性变换），其中W是维度和输入相当的矩阵，b是截距，一些时候可以写入W里，同时增加一个齐次坐标1。&lt;/li&gt;
&lt;li&gt;计算结果的sum&lt;/li&gt;
&lt;li&gt;将结果作为输入载入激活函数，判断激活度，以偏置函数判断是否激活该节点。&lt;br&gt;16-10-08&lt;br&gt;CDN-dns服务器的CNAME如果指向dns智能负载均衡服务器，则通过CDN指派最快的的节点（一般根据用户IP）解析域名获取IP地址，并把缓存服务器没有超过TTL的内容直接传送给用户，包括静态页面、图片等。极大的节省了带宽和网络延时。每个节点都包含高速缓存服务器和负载均衡服务器，主要的内容有&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;约瑟夫环-通项公式为F(1)=0;F(i)=F(i+m)%k,循环从2-N。其中i为有i个人参与游戏，F(i)为i个人参与游戏最后一个人的ID（0开始的ID)&lt;/p&gt;
&lt;p&gt;mysql主从备份-也叫双热备份。主要执行的是可中断的备份程序，在配置文件ini或者cnf中设置主从关系（密码，用户名，host，ID），然后grant duplication 设置slave的权限。然后使用逻辑备份的mysqldump进行备份。&lt;/p&gt;
&lt;p&gt;索引的设置：在经常查询、连接（主要是外检）、排序、group by、范围查询的列上进行可以显著加快查询效率；不应在修改性能远大于检索性能、数值范围很少、查询较少、数据类型为textimagebit等的增加索引。主要有三种索引类型：唯一索引（不允许任意两行相同）、主键（唯一表示数据行的某列）索引、聚集索引（物理顺序与逻辑顺序相同）。&lt;/p&gt;
&lt;p&gt;范式-第一范式 每一列不可以有多个值；第二范式 每个实例或行必须被唯一地区分。（一般用primary key）；第三范式 不依赖其他非主属性&lt;/p&gt;
&lt;p&gt;数据库优化-&lt;br&gt;1.SQL(避免使用!= &amp;lt;&amp;gt;操作符，否则将放弃索引进行全盘搜索；避免null值判断、exists替代in，多用where替代having)&lt;br&gt;16-09-17&lt;br&gt;2.索引 如上&lt;br&gt;3.范式优化 消除冗余 适当增加冗余较少jion 表分区。&lt;br&gt;4.水平（解决单表数据增量）、垂直（解决IO 按照增量拆分）拆分表（适应增长）&lt;br&gt;……我以为 我快挂了呢。保持稳定，保持自信。去了趟深圳，投错了门。笔试了N家，家家挂。阿里、腾讯、猿题库、美团、网易互联网、搜狐畅游、爱奇艺、携程……AA啊等着吧。百度-卒；当当=卒；长光-卒；大疆-卒；招行-？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于熵和最大熵和其他&lt;/strong&gt;&lt;br&gt;最近学习到了有关决策树的部分。分裂特征的时候ID3选择的就是熵减少最多的那个特征来进行。所有熵在信息论、物理、系统概论里面好多地方都用到了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;熵的两种表述是不稳定性和信息量，越不稳定信息量也越多，反之亦然。物理系统里可以解释为混乱程度，体系能量程度。&lt;/li&gt;
&lt;li&gt;最大熵理论解释为在已知情况下，不知道的部分最有可能是趋于其最混乱信息量最大最平均的情况。即最大熵是在未知信息的最一般最朴实理解，解释该情况的一个最普遍的实例就是，对一个未知的筛子每个面掷出的概率都是1/6.最大熵保留尽可能大的不确定性而作出最佳的尽量无偏差的决定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;熵&lt;/strong&gt;=信息熵，&lt;strong&gt;联合熵&lt;/strong&gt;=独立分布事件的所有信息量（可能有信息量重叠），信息量重叠的部分即为&lt;strong&gt;互信息&lt;/strong&gt;，&lt;strong&gt;条件熵&lt;/strong&gt;是在已知某（些）事件发生时，另一件事件的所剩信息量，很显然，条件熵+互信息=信息熵。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最基本的一条公式即为信息熵的公式。然鹅，大多数推公式都给出其表达，再给出其性质。恰恰相反，本质上该公式的表达则是从其应具有的性质上得出。由于越未知信息越多熵越大，信息熵具有的性质为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;光滑连续的&lt;/li&gt;
&lt;li&gt;信息应该是能叠加的，相加应大于等于部分&lt;/li&gt;
&lt;li&gt;当两个变量是独立分布的时候，F(x)F(y)理应等于F(x)+F(y).-&amp;gt;显然，这里能够具有该性质的应该是对数函数&lt;/li&gt;
&lt;li&gt;信息越大熵越大&lt;br&gt;取二项分布时的状态，可以得到$$-\sum_{i=0}^{n}p_{i}(x)lg  p_{i}(x)$$.底可以取任何数。&lt;br&gt;一个通俗的例子解释就是-&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;pi为该情况的概率，例如数学之美丽提到的，世界杯一个队夺冠的概率是1/32&lt;/li&gt;
&lt;li&gt;1/pi为独立出现一次这样情况的需要的次数.例如，在不知道情况的情况下，大家实力一样，则1个队夺冠一次需要的次数参加世界杯的次数为32&lt;/li&gt;
&lt;li&gt;$$lg(\frac{1}{p_{i}(x)})$$为系统确认该状况，需要几次。底为2说明系统每次能够区分2个度的情况，例如天平称重量，例如二叉查找树二分查找。猜测世界杯冠军时，当取2为底，表示每次能确认一半的信息，即二分询问lg(pi)=5；若取32为底，则表明每次确认1/32的信息，即挨个球队问问。lg(pi)=1.&lt;/li&gt;
&lt;li&gt;$$p_{i}(x)lg p_{i}(x)$$由于高概率事件常出现，低概率事件不经常出现，其概率与系统表达该情况次数相乘，即为表达该事件所需要的概率次数。&lt;/li&gt;
&lt;li&gt;取所有情况的和，即为系统复现所有概率可能需要的平均次数（也可能为长度、时间等）&lt;br&gt;另一个客观的例子即字符串的概率和二进制的表达。某些二进制字符出现的概率为p(xi)，则样本中需要1/p(xi)次才会出现一个这样的字符，二进制表示需要lg(1/p(xi))位，则每表达一个字符串给与其权重为其出现的概率再求和，即平均每个样本所需要系统复现（表达、分辨）所需要的平均次数（平均信息量）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;系统每次表达两种情况，记做·bit；系统每次复现e种情况，记做ln。然鹅，我们并不关注系统每次能解决多少情况，我们关注的是相同的系统下，不同的时间的概率分布有多少信息量。一般呢，就取lg&lt;/strong&gt;&lt;br&gt;16-08-31&lt;br&gt;Logistic回归是广义上的线性回归（将y变为lny）。它使用了一个单增可微函数，因而损失函数（预计值与实际值以某种函数表达的差异）接近。实际上它们都是指数分布族的函数。&lt;/p&gt;
&lt;p&gt;关于布冯投针试验，3个简易的理解方式（线宽为L 针长为a）：    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;扔圈圈法&lt;/strong&gt;&lt;br&gt;直径为线宽（长度为时πL）的圆扔过去，必有两个点，扔n次必有2n个交点。根据机会均等原则，折成直线的情况扔过去，可能会有0,1,2,3,4个交点，但扔n次也必有2n个点。当针长为a时，显而易见的是a与交点个数m成正比，即m=αa.令a=πL，m=2n,∴α=2n/(πL)，又相交概率P=n/m，所以联立&lt;br&gt;$$ \pi =\frac{2a}{LP} $$    &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;概率密度函数法&lt;/strong&gt;&lt;br&gt;另一种方式根据概率，针中点距离最近的一条线的距离x和与线成的角度Θ服从独立分布，其中&lt;br&gt;x∈[0,L/2],服从均匀分布，其概率密度函数为2/L&lt;br&gt;Θ∈[0,π/2],服从均匀分布，其概率密度函数为2/π&lt;br&gt;由于x,Θ是相互独立的，所以两者结合的概率为两者概率密度函数的积：4/πL。&lt;br&gt;当满足相交的条件时，x≤a/2*sin(Θ)。凡是一切满足该情况的积分起来就好了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$P=\int_{0}^{\frac{\pi }{2}}\int_{0}^{\frac{a}{2}sin(\theta)}\frac{4}{\pi L}dxd\theta =\frac{2a}{\pi L}$$亦可得到上解法。&lt;/p&gt;
&lt;p&gt;16-08-29&lt;br&gt;py的机器学习包调用的好的好简单啊。。数据清洗和筛选都很舒服。。&lt;/p&gt;
&lt;p&gt;关于Java集合框架(JCF)，主要的接口和类有：&lt;br&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/08/29/57c452fde4a68.png&quot; alt=&quot;JCF&quot;&gt;&lt;br&gt;List下面都有提到，现在主要来讨论Set和Queue。值得一提的是，Set其实是一种特殊的Map。将键和值都赋为相同的值，Set为Map的一种适配器模式，即只实现了想实现的功能，其他Map的功能我不要。同时，由于在JDK1.6以后，Deque实现了双向链表的功能，也封装了顶部加入和弹出、底部加入和弹出的功能，实际完成了Stack的基本操作，所以Stack基本被Deque取代了。可以将Deque看做实现了基本所有优先队列功能的接口，其唯一实现类是LinkedList(它继承自AbstractList，因为也带有List基本的功能，好屌啊).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个很重要&lt;/strong&gt;&lt;br&gt;下图为集合框架的实现方式。&lt;br&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/08/29/57c45a1026983.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;可以看到，LinkedList几乎即实现了双链表又实现了List集合的功能；而基于红黑树的TreeMap和TreeSet能在O(lg(n))时间内完成数据的插入、删除、查找等基本操作。而链表和数组不同方式实现了的List则对于插入和删除有显而易见不同的时间复杂度。LinkedHash两者并存也是神奇的存在，一个Map里，在哈希表的slot里面插入同一位置的使用链表存放，并把链表尾端链到下一个有值的槽的键值上。。虽然很好用，但是，大量的数据需要开很大的空间来存放指针。&lt;/p&gt;
&lt;p&gt;集合框架都能使用.hasNext函数来使用迭代器进行遍历，当然，foreach大法也很好。&lt;/p&gt;
&lt;p&gt;16-08-28&lt;br&gt;近日复习了机器学习线性回归和Logistic回归。前者只需记住j(Θ)的推导和最终结论$$\theta =(X^{T}X)^{-1}X^{T}Y$$或者$$\theta =(X^{T}X+\lambda I)^{-1}X^{T}Y$$即可；为了排除求逆的复杂度则进行梯度下降也是极好。    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Batch（批量梯度下降）&lt;br&gt;$$ \theta_{j} += \alpha \sum^m_{i=1}(y^i-h_\theta(x^{(i)}))x^{(i)}_j$$&lt;br&gt;其中α是步长(学习因子)，h为Θ相关的预测，xy均已知，该方法每步需迭代所有数据&lt;/li&gt;
&lt;li&gt;stachastic（随机梯度下降）&lt;br&gt;$$ \theta_j += \alpha (y^i-h_\theta(x^{(i)}))x^{(i)}_j$$&lt;br&gt;同上类似 但每步只加入一个数据进行梯度计算迭代。&lt;/li&gt;
&lt;li&gt;mini batch（结合上俩式结合一小部分的数据进行迭代而非全部也不是一个）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;回归不适用于分类，尤其是多分类。原理回归曲线的点会严重影响回归函数。&lt;/li&gt;
&lt;li&gt;局部加权回归是在求解梯度时在求和部分加入一个ω函数，使得残杀服从某种分布，一般选择ω为高斯核函数。&lt;/li&gt;
&lt;li&gt;J(Θ)采用的是似然函数求取极值的方式来计算参数；回归时很可能需要先验知识对数据加入某一特征的二次、三次作为新的特征来拟合回归函数。    &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;16-08-25&lt;br&gt;复习leetcode的一些基本题。两个排序数组取中值的，这个真心想了好久。虽知道是分支，但就是解决不好头尾和递推条件。还有很经典的子数组max和，子数组max积，股票买卖那几个动归的问题。单独拿那个取中值的说一下。&lt;/p&gt;
&lt;p&gt;这个算法最直接的当阿然是O(n)把排序数组重合。与快拍里面的一小节类似。但是要更快，就需要更好的思维过程了。&lt;/p&gt;
&lt;p&gt;想到分治必然是划分小区间，然而已经有两段了如何划分更 .0小的区间，一划就成4个了。然而转念一想，取中值，必然是两组里面分别小于中值的和两组里面分别大于中值的共四组。设A B倆数组，长度分别是m,n.约定划分在i∈[0,m-1],j∈[0,n-1]。这样，AB分为了左右两组，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Left&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Right&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;A[0]~A[i]&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;A[i+1]~B[m-1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;B[0]~B[j]&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;B[j+1]~B[n-1]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;当且仅当以下条件满足时，找到了合适的i和j。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A[i]&amp;lt;B[j+1]且B[j]&amp;lt;A[i+1] (即保证严格左堆小于又堆)&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;16-08-24&lt;br&gt;关于高并发 synchronized可以针对&lt;strong&gt;静态函数 实例方法和类对象&lt;/strong&gt;进行阻塞。当访问到里临界区资源时，不但不能写入，同时亦不能读取，防止读取到副本而做出超出预计的运算。HashMap和ArrayList在多线程时一定不能用。    &lt;/p&gt;
&lt;p&gt;针对synchronized很方便的加锁方式，重入锁可以很好的完全替代它。它的主要作用有在中断时给予响应，对某锁申请限制时间的等待，给与申请锁的线程公平的获得机会（防止饥饿产生）。其主要的方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lock()获得锁 如果已被占用则等待。&lt;/li&gt;
&lt;li&gt;lockInterruptibly()获得锁，但有响应则优先&lt;/li&gt;
&lt;li&gt;tryLock()尝试获得锁，获得失败直接返回false，获得成功则返回true&lt;/li&gt;
&lt;li&gt;tryLock(long time,TimeUnit unit)一个参数表示长度，一个参数表示单位。限定时间内尝试获得锁。&lt;/li&gt;
&lt;li&gt;unLock()释放锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而使用condition来配合完成wait和notify操作。&lt;/p&gt;
&lt;p&gt;16-08-22&lt;/p&gt;
&lt;h3 id=&quot;关于ArrayList与Vector&quot;&gt;&lt;a href=&quot;#关于ArrayList与Vector&quot; class=&quot;headerlink&quot; title=&quot;关于ArrayList与Vector&quot;&gt;&lt;/a&gt;关于ArrayList与Vector&lt;/h3&gt;&lt;p&gt;同步性及线程安全不同、自增方式不同；底层均基于数组（Object[]）实现，可随机访问，查询增删效率相同。&lt;br&gt;List&lt;t&gt;接口有三个实现类，ArrayList、Vector、LinkedList。前两个基于数组实现，物理位置应该是连续的；LinkedList类似C语言的链表，删除时，查询效率是O(i),i为index,而删除时指针改变效率为O(1).而两者查询效率为O(1),删除时效率为O(n-i).&lt;br&gt;LinkedList通过双链表维护，因而可以轻易的转换为栈和队列（Stack Queue Deque）等优先队列的结构。&lt;br&gt;要得到一个同步的LinkedList可以使用同步封装器实现,从Collections.synchronizedList(List)得到。但Vector就不需要进行额外的调用，尤其是在访问和更新。    &lt;/t&gt;&lt;/p&gt;
&lt;p&gt;LinkedList定义了专门用于表头和表尾操作的方法。Vector提供了indexOf(obj,start)接口，arrayList没有这个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List和Map中，只有Vector和HashTable能维护高效的同步&lt;/strong&gt;&lt;br&gt;List的继承链大致为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;+--java.util.Collection[I](集合框架接口)
   +--java.util.List[I](存放一类元素 可重复 有序 以下三者均继承自抽象类AbstractList，由其实现List接口。)
      +--java.util.ArrayList[C]
      +--java.util.LinkedList[C]
      +--java.util.Vector[C]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有的类要么继承自List要么继承自Set，不能直接实现Collection。&lt;br&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/08/22/57bbc0d99a834.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AbstractList&lt;/strong&gt;是一个抽象类，继承自&lt;strong&gt;AbstractCollection&lt;/strong&gt;,AbstractList实现了除size()和get(int location)之外的函数。LinkedList与正常基于数组的不同，其通过AbstractSequentialList这一抽象类继承了AbstractList并额外添加了对链表的各项操作，又实现了Deque接口而完成了双向链表的功能。可以看到，&lt;strong&gt;Queue和Deque的唯一实现类都是LinkedList&lt;/strong&gt;.Stack该类继承自Vector，完成了先进后出的操作。&lt;/p&gt;
&lt;h3 id=&quot;关于线程安全&quot;&gt;&lt;a href=&quot;#关于线程安全&quot; class=&quot;headerlink&quot; title=&quot;关于线程安全&quot;&gt;&lt;/a&gt;关于线程安全&lt;/h3&gt;&lt;p&gt;线程安全的类 ，指的是&lt;strong&gt;类内共享的全局变量的访问必须保证是不受多线程形式影响的&lt;/strong&gt;。&lt;br&gt;多线程保持原子性、可见性、有序性（涉及指令重排）&lt;/p&gt;
&lt;p&gt;16-08-21&lt;br&gt;复习了小顶堆 大顶堆的插入。以树为逻辑以数组为存储的结构。初始化第一个位置置为null或者0.插入在末尾进行heapUp,删除替换末尾进行heapDown,排序也是进行heapDown的操作。    &lt;/p&gt;
&lt;p&gt;16-08-20&lt;br&gt;TreeMap是基于红黑树的SortedMap的实现。SortedMap是基于键的大小自动运行比较器的Map集合框架，正规的实现该接口必须包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不含餐的构造函数 插入时按照键自然顺序排序&lt;/li&gt;
&lt;li&gt;实现一个comparatot的构造函数 按照比较器给定的顺序排序。该比较器应定义良好。&lt;/li&gt;
&lt;li&gt;带Map的构造函数 创建参数相同的有序映射 按照自然顺序排序&lt;/li&gt;
&lt;li&gt;带有序映射类型的构造函数，使其顺序、比较方式、键值映射关系与给定有序映射类型相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其修改不是同步的，不是线程安全的。所以尽量在创建时完成这一操作，或使用Collections集合的同步方法，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;  Map m = Collections.synchronizedMap(new TreeMap(...));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他：key不可以为空，value可为空；相同值的插入会覆盖前面的。&lt;br&gt;16-08-20&lt;br&gt;心疼李宗伟&lt;br&gt;复习了树的前驱后继的求法。求前有左求后有右都好求，关键的是相反的话，需要记录最接近的拐点，同时记录父母亲（如果是向的树），这样可以避免中序遍历的O(N)时间复杂度而变成O(lg(N))的二分查找复杂度。&lt;/p&gt;
&lt;p&gt;16-08-18&lt;br&gt;复习了非递归树的遍历 主要是栈的应用。利用单队列 双队列实现层次遍历。树的旋转还是容易变化，删除操作里的三种情况也要记住。删除二儿子节点找到前驱或者后继（右子树最左 左子树最右）并替换之，并按照一儿子或者0儿子的删除将该节点删除。&lt;/p&gt;
&lt;p&gt;16-08-17&lt;br&gt;tire树几个特征：适用单词（短语）模糊推荐 N叉树-多基于单词分叉-每个节点独设标记位记录是否为单词节点   一些方案中记录共用该节点单词数（非到叶子路径数）使得查询时间复杂度O(lg(kN)).k为当前查询字符长度 N为最多分支数。&lt;br&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/08/18/57b5962f1d2d2.gif&quot; alt=&quot;trie树&quot;&gt;    &lt;/p&gt;
&lt;p&gt;尝试一下 有道的网页笔试 其中一道题是分两摞的洗牌问题。从上到下1、2……N标号的纸牌，各取一半，左下取一张，右下取一张，左下取第二张，右下取第二张……以此类推，和正常洗牌类似，求k次洗牌后的顺序。牌堆编号给出。例如1,2,3,4,5,6洗一次后变为4,1,5,2,6,3.额。。。尝试了暴力求解 但是应该能有什么规律似的。尝试给每张牌记录是否存在的记号，还是略微痛苦。    &lt;/p&gt;
&lt;p&gt;接近刷完了算法导论的课程，更多的接近于概率论的算法证明课。收获的很扎实，但是还是书看的快，权当是复习算法的内涵和合理性部分了。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;近期忙着撸工作。边学边总结。&lt;br&gt;
    
    </summary>
    
    
      <category term="learn" scheme="http://ovjaywang.github.io/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>Git的小tips</title>
    <link href="http://ovjaywang.github.io/2016/06/14/git%E7%9A%84%E5%B0%8Ftips/"/>
    <id>http://ovjaywang.github.io/2016/06/14/git的小tips/</id>
    <published>2016-06-14T12:59:12.000Z</published>
    <updated>2017-01-17T16:44:28.000Z</updated>
    
    <content type="html">&lt;p&gt;Git是当下最流行最舒适的版本控制系统。这里大致把git容易忘记的事情做小结。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Git-Tips&quot;&gt;&lt;a href=&quot;#Git-Tips&quot; class=&quot;headerlink&quot; title=&quot;Git Tips&quot;&gt;&lt;/a&gt;Git Tips&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Git的机制&quot;&gt;&lt;a href=&quot;#Git的机制&quot; class=&quot;headerlink&quot; title=&quot;Git的机制&quot;&gt;&lt;/a&gt;Git的机制&lt;/h2&gt;&lt;p&gt;记录每次commit的快照及镜像，而非版本增量。完全的分布式及提倡多分支非线性开发。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似CVS Subversion记录次提交时更新的文件及更新了哪些内容。&lt;/li&gt;
&lt;li&gt;Git则将快照记录在微型文件系统中，并使用指针(索引)指向当前快照以区别版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Git每次提交不必联网 大部分操作在本地完成 只在完成一部分功能或需要共享时提交远程仓库 节约了流量 提升了效率 无网络状态亦可提交更新及浏览历史。&lt;/p&gt;
&lt;h2 id=&quot;Git的四个状态&quot;&gt;&lt;a href=&quot;#Git的四个状态&quot; class=&quot;headerlink&quot; title=&quot;Git的四个状态&quot;&gt;&lt;/a&gt;Git的四个状态&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;!http://ooo.0o0.ooo/2016/06/14/57600bfe92c91.png&quot;&gt;Git的四个状态&lt;/a&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未追逐 新添加之前未有版本信息的文件 将未追踪的添加到版本管理使用&lt;strong&gt;add&lt;/strong&gt;命令&lt;/li&gt;
&lt;li&gt;已追踪有三类（已修改 未修改 已暂存）&lt;/li&gt;
&lt;li&gt;未修改 一个时间点做了快照之后未修改的就是未修改 只要做出任意改动就会变成&lt;/li&gt;
&lt;li&gt;已修改 此时若修正好 需要把文件添加到暂缓存区 同样使用&lt;strong&gt;add&lt;/strong&gt; 命令&lt;/li&gt;
&lt;li&gt;已暂存 此时暂时存储在内存中 需要把它永久的存在硬盘的git本地系统中 使用&lt;strong&gt;commit&lt;/strong&gt;提交命令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用下命令显示本目录下的文件跟踪情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用下命令查看修改和比较两个版本差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git diff
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;跟踪一个有趣的远程仓库&quot;&gt;&lt;a href=&quot;#跟踪一个有趣的远程仓库&quot; class=&quot;headerlink&quot; title=&quot;跟踪一个有趣的远程仓库&quot;&gt;&lt;/a&gt;跟踪一个有趣的远程仓库&lt;/h2&gt;&lt;p&gt;其实要做的只是 copy下来；过一段时间、知道它有更新的时候就pull一下，拉取下来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git clone git://github.com/[user_name]/[project_name].git
..
git pull origin project_name
## 或者
git fetch origin project_name
git merge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;键入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git remote show origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以查看到以下几个关键的东西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;local branch pushed with ‘git push’ 缺省推送分支&lt;/li&gt;
&lt;li&gt;caching 那些远端分支还未同步到本地&lt;/li&gt;
&lt;li&gt;stale tracking branches那些分支已经在远端被删除&lt;/li&gt;
&lt;li&gt;Remote branch merged with ‘git pull’ while on branch  git pull时自动合并那些分支&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;小逼格&quot;&gt;&lt;a href=&quot;#小逼格&quot; class=&quot;headerlink&quot; title=&quot;小逼格&quot;&gt;&lt;/a&gt;小逼格&lt;/h2&gt;&lt;h3 id=&quot;加标签&quot;&gt;&lt;a href=&quot;#加标签&quot; class=&quot;headerlink&quot; title=&quot;加标签&quot;&gt;&lt;/a&gt;加标签&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git tag [tag_name] #写入tag
git tag #显示所有tag
git show [tag_name] -lw #显示某个tag名字的提交
git tag -a [tag_name] [commit_code] #给忘记添加标记的提交起个标签
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;查看日志&quot;&gt;&lt;a href=&quot;#查看日志&quot; class=&quot;headerlink&quot; title=&quot;查看日志&quot;&gt;&lt;/a&gt;查看日志&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git log 
e.g. 
git log --pretty=format:&amp;quot;%h - %an, %ar : %s&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上式以一个很优美的显示方案：哈希字符串、对象、时间、提交的说明 一行一个提交显示。&lt;br&gt;对于可显示选项，可选用下表备用词。&lt;/p&gt;
&lt;table class=&quot;table table-bordered table-striped table-condensed&quot;&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;选项 &lt;/td&gt;&lt;br&gt;        &lt;td&gt;说明&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;-p &lt;/td&gt;&lt;br&gt;        &lt;td&gt;按补丁格式显示每个更新之间的差异。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–word-diff &lt;/td&gt;&lt;br&gt;        &lt;td&gt;按 word diff 格式显示差异。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–stat &lt;/td&gt;&lt;br&gt;        &lt;td&gt;显示每次更新的文件修改统计信息。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–shortstat &lt;/td&gt;&lt;br&gt;        &lt;td&gt;只显示 –stat 中最后的行数修改添加移除统计。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–name-only &lt;/td&gt;&lt;br&gt;        &lt;td&gt;仅在提交信息后显示已修改的文件清单。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–name-status &lt;/td&gt;&lt;br&gt;        &lt;td&gt;显示新增、修改、删除的文件清单。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–abbrev-commit &lt;/td&gt;&lt;br&gt;        &lt;td&gt;仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–relative-date &lt;/td&gt;&lt;br&gt;        &lt;td&gt;使用较短的相对时间显示（比如，“2 weeks ago”）。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–graph &lt;/td&gt;&lt;br&gt;        &lt;td&gt;显示 ASCII 图形表示的分支合并历史。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–pretty &lt;/td&gt;&lt;br&gt;        &lt;td&gt;使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;–oneline &lt;/td&gt;&lt;br&gt;        &lt;td&gt;–pretty=oneline –abbrev-commit 的简化用法。&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;&lt;/table&gt;&lt;br&gt;而对于pretty中的格式，可以自由设定，如下表标注。&lt;br&gt;&lt;table&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;选项 &lt;/td&gt;&lt;br&gt;        &lt;td&gt;说明&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%H &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交对象（commit）的完整哈希字串&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%h &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交对象的简短哈希字串&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%T &lt;/td&gt;&lt;br&gt;        &lt;td&gt;树对象（tree）的完整哈希字串&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%t &lt;/td&gt;&lt;br&gt;        &lt;td&gt;树对象的简短哈希字串&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%P &lt;/td&gt;&lt;br&gt;        &lt;td&gt;父对象（parent）的完整哈希字串&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%p &lt;/td&gt;&lt;br&gt;        &lt;td&gt;父对象的简短哈希字串&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%an &lt;/td&gt;&lt;br&gt;        &lt;td&gt;作者（author）的名字&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%ae &lt;/td&gt;&lt;br&gt;        &lt;td&gt;作者的电子邮件地址&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%ad &lt;/td&gt;&lt;br&gt;        &lt;td&gt;作者修订日期（可以用 -date= 选项定制格式）&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%ar &lt;/td&gt;&lt;br&gt;        &lt;td&gt;作者修订日期，按多久以前的方式显示&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%cn &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交者(committer)的名字&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%ce &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交者的电子邮件地址&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%cd &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交日期&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%cr &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交日期，按多久以前的方式显示&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;        &lt;td&gt;%s &lt;/td&gt;&lt;br&gt;        &lt;td&gt;提交说明&lt;/td&gt;&lt;br&gt;    &lt;/tr&gt;&lt;br&gt;&lt;/table&gt;

&lt;h2 id=&quot;自动补全-命令别名&quot;&gt;&lt;a href=&quot;#自动补全-命令别名&quot; class=&quot;headerlink&quot; title=&quot;自动补全-命令别名&quot;&gt;&lt;/a&gt;自动补全-命令别名&lt;/h2&gt;&lt;p&gt;相当酷炫而有用。直接看&lt;a href=&quot;http://www.fenby.com/courses/sections/ji-qiao-he-qiao-men/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;Git是当下最流行最舒适的版本控制系统。这里大致把git容易忘记的事情做小结。&lt;br&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://ovjaywang.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>位运算各种</title>
    <link href="http://ovjaywang.github.io/2016/05/12/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%84%E7%A7%8D/"/>
    <id>http://ovjaywang.github.io/2016/05/12/位运算各种/</id>
    <published>2016-05-12T03:12:00.000Z</published>
    <updated>2016-08-30T13:32:36.000Z</updated>
    
    <content type="html">&lt;p&gt;最近发现位运算在很多场合有很多运用啊。大概有以下几个方面:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;涉及二进制及其2^n进制的运算&lt;/li&gt;
&lt;li&gt;很少字段的struct class的改写例如棋盘记录和模式比较&lt;/li&gt;
&lt;li&gt;逼格&amp;amp;效率比较高的小心机&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;几个运算符&quot;&gt;&lt;a href=&quot;#几个运算符&quot; class=&quot;headerlink&quot; title=&quot;几个运算符&quot;&gt;&lt;/a&gt;几个运算符&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;符号&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;名称&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位亦或&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;同为0，异为1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$\mid $&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位或&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;有1则1，双0为0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位与&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;有0则0，双为1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位取反&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;变1为0，变0为1（包含符号位）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位左移（包括符号）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;二进制每移一位乘二,最右补零&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位右移（包括符号）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;二进制每移一位除二,无符号最左补零，有符号补符号位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;`&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位无符号右移&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对应二进制全指定的位数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上均是按位操作，要区分逻辑运算&lt;code&gt;&amp;amp;&amp;amp; ||&lt;/code&gt;和位运算符&lt;code&gt;&amp;amp; |&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;关于取反&quot;&gt;&lt;a href=&quot;#关于取反&quot; class=&quot;headerlink&quot; title=&quot;关于取反&quot;&gt;&lt;/a&gt;关于取反&lt;/h1&gt;&lt;p&gt;普通的Integer char等按位操作都是直接按照它们的二进制补码操作，int直接使用该数字的补码，char则先按照ascii转换成二进制在进行操作。&lt;br&gt;e.g.&lt;code&gt;char a = &amp;#39;a&amp;#39;&lt;/code&gt;a的ascii码十进制为097，二进制原码为1100001，这里注意，作为char，它在java中是一个&lt;font color=&quot;red&quot;&gt;无符号16位的整数&lt;/font&gt;，所以补齐它的&lt;br&gt;二进制原码 补码 反码（非负数原码 补码 反码相同）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;000000000 1100001&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;取反后的补码&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;111111111 0011110&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;取反后的反码&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;111111111 0011101&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;取反后的源码&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;100000000 1100010&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;十进制即为 &lt;strong&gt;-98&lt;/strong&gt;。&lt;br&gt;同理的，byte如果存储字符型也是按照先转成ascii码进行操作，即便是字符型的数字也一样。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;byte a = 2;
int b = ~a;//输出b为-3
byte c = &amp;#39;2&amp;#39;;
int d = ~c;//输出d为-51 2的ascii为50(十进制) 32(十六进制)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;关于亦或&quot;&gt;&lt;a href=&quot;#关于亦或&quot; class=&quot;headerlink&quot; title=&quot;关于亦或&quot;&gt;&lt;/a&gt;关于亦或&lt;/h1&gt;&lt;p&gt;亦或相当的特别同时阴森啊，有几个性质&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a^a = 0 也就是亦或自己为0，因为每位都是相同的。&lt;/li&gt;
&lt;li&gt;a^a^a = a^0 = 0^a  = a&lt;/li&gt;
&lt;li&gt;a^b = b^a 符合交换律&lt;/li&gt;
&lt;li&gt;(a^b)^c = a^(b^c) 符合结合律&lt;/li&gt;
&lt;li&gt;e = a^b^c^d &amp;lt;-&amp;gt; e^a = b^c^d &amp;lt;-&amp;gt; e^a^b= c^d &amp;lt;-&amp;gt; e^a^b^c=d&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然满足交换律结合律，则如果出现这么一种情况，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[一个数组里除了一个数值出现一次，其他都出现了两次。找出这个数值。]&lt;br&gt;将这个数组全部亦或一遍，则出现两次的都可以按照交换律结合律化为0，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数组内只存在两个奇数次出现的数，其他都出现了偶数次，找出这两个数&quot;&gt;&lt;a href=&quot;#数组内只存在两个奇数次出现的数，其他都出现了偶数次，找出这两个数&quot; class=&quot;headerlink&quot; title=&quot;数组内只存在两个奇数次出现的数，其他都出现了偶数次，找出这两个数&quot;&gt;&lt;/a&gt;数组内只存在两个奇数次出现的数，其他都出现了偶数次，找出这两个数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思路：这就是上面实例的改进，因为知道了其他数字都出现了偶数次，全体亦或的结果就是&lt;code&gt;x=a^b&lt;/code&gt; 其中a b分别是所要找的这两个数。由于a b不同，则x必然不为零，也必然存在为1的位（可以取从右第一次出现1的位置）。同时由于是亦或操作，这个1必然是a和b相异造成的。这样，把这一位为1的分一组，这一位为0的分一组，出现偶数次的依然会被分到一组通过亦或自己消除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    //从右寻找补码中1第一次出现的位置
    public static int getFirst1(int num){
        int index = 0;
        while(index&amp;lt;32){//Integer有32位
            if(((num&amp;amp;(1&amp;lt;&amp;lt;index))^(1&amp;lt;&amp;lt;index))==0)
                return index+1;
            else
                index++;
        }
        return -1;
    }

    //判断这个数这一位是否为1
    public static boolean is1AtPos(int num,int pos){    
        return ((num&amp;gt;&amp;gt;(pos-1))&amp;amp;1)==1;
    }

    //寻找这两个数
    public static int[] get2Num(int[] a){
        int [] find2Num = new int[2];
        //默认初始化0
        int rs = 0;
        for (int i : a) {
            rs ^= i;//亦或全体求x
        int pos=getFirst1(rs);//寻找第一个出现1的位
        for (int j : a) {
            if(is1AtPos(j,pos))//按这位是否位1分组
                find2Num[0] ^= j;
            else
                find2Num[1] ^= j;           
        }
        System.out.println(find2Num[0]+&amp;quot; &amp;quot;+find2Num[1]);
        return find2Num;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;使用位亦或-节约空间的数据交换&quot;&gt;&lt;a href=&quot;#使用位亦或-节约空间的数据交换&quot; class=&quot;headerlink&quot; title=&quot;使用位亦或^节约空间的数据交换&quot;&gt;&lt;/a&gt;使用位亦或^节约空间的数据交换&lt;/h2&gt;&lt;p&gt;原理：a亦或b=c，b亦或a=c，也就是亦或满足交换律；位亦或的逆运算，也就是&lt;code&gt;(a^b)^b=a&lt;/code&gt;等于它自己。所以，只需三个亦或运算即可交换数据。看代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    a ^= b;
    b ^= a;
    a ^= b;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;使用亦或加密&quot;&gt;&lt;a href=&quot;#使用亦或加密&quot; class=&quot;headerlink&quot; title=&quot;使用亦或加密&quot;&gt;&lt;/a&gt;使用亦或加密&lt;/h2&gt;&lt;p&gt;中文配合亦或加密再加上其他的一些加密算法可以很好的掩护原文。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        char  a1=&amp;#39;晚&amp;#39; ,  a2=&amp;#39;上&amp;#39; ,  a3=&amp;#39;来&amp;#39; ,  a4=&amp;#39;我&amp;#39;,  a5=&amp;#39;家&amp;#39; ; 
        char secret=&amp;#39;8&amp;#39; ; 
        a1=(char) (a1^secret); 
        a2=(char) (a2^secret); 
        a3=(char) (a3^secret); 
        a4=(char) (a4^secret); 
        a5=(char) (a5^secret); 
        System.out.println(&amp;quot;密文:&amp;quot;+a1+a2+a3+a4+a5); 
        a1=(char) (a1^secret); 
        a2=(char) (a2^secret); 
        a3=(char) (a3^secret); 
        a4=(char) (a4^secret); 
        a5=(char) (a5^secret); 
        System.out.println(&amp;quot;原文:&amp;quot;+a1+a2+a3+a4+a5);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;亦或判别IP地址是否相等&quot;&gt;&lt;a href=&quot;#亦或判别IP地址是否相等&quot; class=&quot;headerlink&quot; title=&quot;亦或判别IP地址是否相等&quot;&gt;&lt;/a&gt;亦或判别IP地址是否相等&lt;/h2&gt;&lt;p&gt;使用亦或在加上按位与的方式比==加&amp;amp;&amp;amp;的方式效率高。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    static int ipv6_addr_equal(int[] in6_addr_a1, int[] in6_addr_a2)
    {
    return (((in6_addr_a1[0] ^ in6_addr_a2[0]) |
        (in6_addr_a1[1] ^ in6_addr_a2[1]) |
        (in6_addr_a1[2] ^ in6_addr_a2[2]) |
        (in6_addr_a1[3] ^ in6_addr_a2[3])) == 0);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;关于按位与&quot;&gt;&lt;a href=&quot;#关于按位与&quot; class=&quot;headerlink&quot; title=&quot;关于按位与&quot;&gt;&lt;/a&gt;关于按位与&lt;/h1&gt;&lt;p&gt;按位与操作一般是与1配合 判断奇偶，或者判断某位是否为1；或保留下某位位数字(与位移结合)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a&amp;amp;1 == 0    偶数
a&amp;amp;1 == 1    奇数
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;关于按位与-1&quot;&gt;&lt;a href=&quot;#关于按位与-1&quot; class=&quot;headerlink&quot; title=&quot;关于按位与&quot;&gt;&lt;/a&gt;关于按位与&lt;/h1&gt;&lt;p&gt;按位或操作一般与0配合 &lt;/p&gt;
&lt;h1 id=&quot;按位左右移&quot;&gt;&lt;a href=&quot;#按位左右移&quot; class=&quot;headerlink&quot; title=&quot;按位左右移&quot;&gt;&lt;/a&gt;按位左右移&lt;/h1&gt;&lt;p&gt;左右移本质上就是以bit为单元进行二进制的操作，而二进制左右移n位在十进制就意味着乘以2^n或除以2^n.按位操作可以大大提升效率&lt;br&gt;港真，很多面试都有求幂的题目。很棒，刷题狗就喜欢做这种题，然而第一次碰到这题我懵逼的采用了树。傻缺了。&lt;/p&gt;
&lt;p&gt;将二进制数绕圈循环，取往左(右)第k个为头。很多题目里面有啊&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;int a = a&amp;lt;&amp;lt;k | a &amp;gt;&amp;gt; (Integer.SIZE-k); //左数第k个当头
int b = b&amp;gt;&amp;gt;k | b &amp;gt;&amp;gt; (Integer.SIZE-k); //右数第k个当头
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第k位置1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    a|(1&amp;lt;&amp;lt;k);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第k位置0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    a&amp;amp;(~(1&amp;lt;&amp;lt;k));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;取第k位的数值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    a&amp;gt;&amp;gt;k&amp;amp;1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后k位为0，其余为1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    (~0)&amp;amp;(1&amp;lt;&amp;lt;(k+1));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后k位为1，其余为0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    ~((~0)&amp;lt;&amp;lt;k);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;左右移应用-二分求幂&quot;&gt;&lt;a href=&quot;#左右移应用-二分求幂&quot; class=&quot;headerlink&quot; title=&quot;左右移应用-二分求幂&quot;&gt;&lt;/a&gt;左右移应用-二分求幂&lt;/h2&gt;&lt;p&gt;&lt;strong&gt; &lt;font color=&quot;red&quot;&gt;Caution！这个思想很重要!&lt;/font&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;思路：求a^b，如果b是一个2的整数幂，举个栗子，32，那可以进行这样的迭代，由于$32=2^5$,那么就可以这样求，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;第一次求 $a_1=a^2$  &lt;/li&gt;
&lt;li&gt;第二次求 $a_2=a^4=a^{2*2}={a_1}^2$  &lt;/li&gt;
&lt;li&gt;第三次求 $a_3=a^8=a^{4*2}={a_2}^2$  &lt;/li&gt;
&lt;li&gt;第四次求 $a_4=a^{16}=a^{8*2}={a_3}^2$&lt;/li&gt;
&lt;li&gt;第五次求 $a_5=a^{32}=a^{16*2}={a_4}^2$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果是通过迭代幂的次数，需要32次才能达到，然而通过分治的方式，只需要5次就能解算32次幂。那如果不是2的整数幂次方呢，很好办，通过将该整数分解成各个2的整数次幂的和，例如求取a的23次方,又$23=16+4+2=1$，所以原式可化为$a^{2^4+2^2+2^1+2^0}$,通过二分的方式，变形为$$(a^{16})\cdot (a^4)\cdot (a^1)\cdot (a^0)$$.&lt;br&gt;显然！上式就是二进制和十进制转换的过程，通过4+2+1=7次计算就可解出，而非单循环的23次。&lt;br&gt;其实，解算a的16次方中，即可用到$${a^4}^{2^2}$$,即计算a^的16次方只需用到2步，总共2+2+1=5次迭代就可计算完毕。&lt;br&gt;因而解决a^b次幂的步骤是  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将幂次化为2进制  &lt;/li&gt;
&lt;li&gt;从低位遍历，为1则乘以当前幂次，为0则计算当前幂次，然后跳过，直接移至下一位  &lt;/li&gt;
&lt;li&gt;当幂指数的二进制推到最高位  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static long Power(int a, int n){
        long ans = 1;
        System.out.println(&amp;quot;幂指数二进制：&amp;quot;+Integer.toBinaryString(n));
        while (n &amp;gt; 0) {
            if ((n &amp;amp; 1)!=0) {//末位不为零
                ans *= a;
            } 
            a *= a;//计算当前幂次
            n &amp;gt;&amp;gt;= 1;//迭代每次推一位
        }
        return ans;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归版本可能更清晰&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static int power(int a,int n)  {  
        if(n==1) return a;  
        if(n&amp;amp;1)  
          return power(a,n-1) * a;  
        else  
        {  
            int t=power(a,n&amp;gt;&amp;gt;1);  
            return t*t;  
        }  
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面还有更&lt;strong&gt;炸裂&lt;/strong&gt;的&lt;/p&gt;
&lt;h2 id=&quot;利用位移求二进制里1的奇偶&quot;&gt;&lt;a href=&quot;#利用位移求二进制里1的奇偶&quot; class=&quot;headerlink&quot; title=&quot;利用位移求二进制里1的奇偶&quot;&gt;&lt;/a&gt;利用位移求二进制里1的奇偶&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一般的思路就是，一位一位截末位，为1则亦或一下，为0则不管。对于Integer需要循环32次，对byte需要循环8次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1数量为奇则返回1，为偶数则返回0。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static int get11Count(int x){
            int i=0;
            for(int j =0 ;j&amp;lt;32;j++){
                if((x&amp;amp;1)==1)
                    i ^= x&amp;amp;1;  
                x &amp;gt;&amp;gt;= 1;
            }
            return i;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;但四，这个方式没有体现位移的优越性。通过分治的思想，由于结果只求1或0，那么通过1位表达2位的信息，通过2位表达4位的信息，通过4位表达8位的信息，通过8位表达16位的信息，通过16位表达32位的信息。通过五次&lt;strong&gt;表达&lt;/strong&gt;，就可以求出结果。&lt;br&gt;最关心的，其实只是&lt;font color=&quot;red&quot;&gt;最后一位&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static int get1Count(int x){
    //返回二进制数有偶数还是奇数个1 偶数返回0 奇数返回1
            x = x ^ (x &amp;gt;&amp;gt; 1);
            x = x ^ (x &amp;gt;&amp;gt; 2);
            x = x ^ (x &amp;gt;&amp;gt; 4);
            x = x ^ (x &amp;gt;&amp;gt; 8);
            x = x ^ (x &amp;gt;&amp;gt; 16);
        return x&amp;amp;1;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;解析一下。先拿byte举个栗子。因为byte是1个字节8个bit，所以表达-128~127即$-2^7\sim 2^7$.按照上面的方式，只需右移三次.举个例子88，二进制为$2^6+2^4+2^3=1011000$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        01011000
        00101100
    xor --------
        01110100  -&amp;gt;这个是结果！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果的数值含义是，将原式中，这一位i与该位的上一位(即第i+1位)做了一次亦或，&lt;font color=&quot;red&quot;&gt;结果式中每出现一个1，则代表原式中必然邻位相异。&lt;/font&gt;其实，由于最终结果只需要表述奇偶，因此两个1为0，等同于抵消的含义。&lt;/p&gt;
&lt;p&gt;第二次亦或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        01110100
        00011101
    xor --------
        01101001 —&amp;gt;第二次的结果
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果的含义是，每一个数字1表示##原式##中，每一位与其前3位二进制数值中1的个数为奇数；每一个数字0表示##原式##中，每一位与其前3位二进制数值中1的个数为0.&lt;/p&gt;
&lt;p&gt;第三次亦或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
        01101001
        00000110
    xor --------
        01101111 -&amp;gt;第三次结果
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显而易见，每个1的出现表示与其前7个数字1出现奇数次。&lt;br&gt;最后取最后一位&lt;code&gt;x&amp;amp;1&lt;/code&gt;,得到1，即原式中有奇数次1.结果正确。&lt;/p&gt;
&lt;h2 id=&quot;进阶-计算二进制1的个数&quot;&gt;&lt;a href=&quot;#进阶-计算二进制1的个数&quot; class=&quot;headerlink&quot; title=&quot;进阶-计算二进制1的个数&quot;&gt;&lt;/a&gt;进阶-计算二进制1的个数&lt;/h2&gt;&lt;h3 id=&quot;最原始的方式&quot;&gt;&lt;a href=&quot;#最原始的方式&quot; class=&quot;headerlink&quot; title=&quot;最原始的方式&quot;&gt;&lt;/a&gt;最原始的方式&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;    int BitCount(unsigned int n)
    {
        unsigned int c =0 ; // 计数器
        while (n &amp;gt;0)
        {
            if((n &amp;amp;1) ==1) // 当前位是1
                ++c ; // 计数器加1
            n &amp;gt;&amp;gt;=1 ; // 移位
        }
        return c ;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;原始方式的改进&quot;&gt;&lt;a href=&quot;#原始方式的改进&quot; class=&quot;headerlink&quot; title=&quot;原始方式的改进&quot;&gt;&lt;/a&gt;原始方式的改进&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;    int BitCount1(unsigned int n)
    {
        unsigned int c =0 ; // 计数器
        for (c =0; n; n &amp;gt;&amp;gt;=1) // 循环移位
            c += n &amp;amp;1 ; // 如果当前位是1，则计数器加1
        return c ;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;亦或清1法&quot;&gt;&lt;a href=&quot;#亦或清1法&quot; class=&quot;headerlink&quot; title=&quot;亦或清1法&quot;&gt;&lt;/a&gt;亦或清1法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;int BitCount2(unsigned int n)
{
    unsigned int c =0 ;
    for (c =0; n; ++c)
    {
        n &amp;amp;= (n -1) ; // 清除最低位的1
    }
    return c ;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;查表法1：&quot;&gt;&lt;a href=&quot;#查表法1：&quot; class=&quot;headerlink&quot; title=&quot;查表法1：&quot;&gt;&lt;/a&gt;查表法1：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;int BitCount3(unsigned int n) 
{ 
    // 建表
    unsigned char BitsSetTable256[256] = {0} ; 

    // 初始化表 
    for (int i =0; i &amp;lt;256; i++) 
    { 
        BitsSetTable256[i] = (i &amp;amp;1) + BitsSetTable256[i /2]; 
    } 

    unsigned int c =0 ; 

    // 查表
    unsigned char* p = (unsigned char*) &amp;amp;n ; 

    c = BitsSetTable256[p[0]] + 
        BitsSetTable256[p[1]] + 
        BitsSetTable256[p[2]] + 
        BitsSetTable256[p[3]]; 

    return c ; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;查表法2：4bit查表&quot;&gt;&lt;a href=&quot;#查表法2：4bit查表&quot; class=&quot;headerlink&quot; title=&quot;查表法2：4bit查表&quot;&gt;&lt;/a&gt;查表法2：4bit查表&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;int BitCount4(unsigned int n)
{
    unsigned int table[16] = 
    {
        0, 1, 1, 2, 
        1, 2, 2, 3, 
        1, 2, 2, 3, 
        2, 3, 3, 4
    } ;

    unsigned int count =0 ;
    while (n)
    {
        count += table[n &amp;amp;0xf] ;
        n &amp;gt;&amp;gt;=4 ;
    }
    return count ;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;查表法3：8bit查表&quot;&gt;&lt;a href=&quot;#查表法3：8bit查表&quot; class=&quot;headerlink&quot; title=&quot;查表法3：8bit查表&quot;&gt;&lt;/a&gt;查表法3：8bit查表&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;int BitCount7(unsigned int n)
{ 
    unsigned int table[256] = 
    { 
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 
    }; 

    return table[n &amp;amp;0xff] +
        table[(n &amp;gt;&amp;gt;8) &amp;amp;0xff] +
        table[(n &amp;gt;&amp;gt;16) &amp;amp;0xff] +
        table[(n &amp;gt;&amp;gt;24) &amp;amp;0xff] ;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###炸裂的平行算法&lt;br&gt;邻位相加，重复这一过程，直到只剩一位。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    #include &amp;lt;stdio.h&amp;gt;
    #include &amp;lt;iostream&amp;gt;

    using namespace std;

    int main(int argc, char *argv[]) {
        int x;
        while (cin &amp;gt;&amp;gt; x) {
            x = (x &amp;amp; 0x55555555) + ((x &amp;gt;&amp;gt; 1) &amp;amp; 0x55555555);
            x = (x &amp;amp; 0x33333333) + ((x &amp;gt;&amp;gt; 2) &amp;amp; 0x33333333);
            x = (x &amp;amp; 0x0F0F0F0F) + ((x &amp;gt;&amp;gt; 4) &amp;amp; 0x0F0F0F0F);
            x = (x &amp;amp; 0x00FF00FF) + ((x &amp;gt;&amp;gt; 8) &amp;amp; 0x00FF00FF);
            x = (x &amp;amp; 0x0000FFFF) + ((x &amp;gt;&amp;gt; 16) &amp;amp; 0x0000FFFF);
            cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl;
        }
        return 0;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###终极大招&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int BitCount5(unsigned int n) 
{
    unsigned int tmp = n - ((n &amp;gt;&amp;gt;1) &amp;amp;033333333333) - ((n &amp;gt;&amp;gt;2) &amp;amp;011111111111);
    return ((tmp + (tmp &amp;gt;&amp;gt;3)) &amp;amp;030707070707) %63;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;补充：位标志法&quot;&gt;&lt;a href=&quot;#补充：位标志法&quot; class=&quot;headerlink&quot; title=&quot;补充：位标志法&quot;&gt;&lt;/a&gt;补充：位标志法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;struct _byte 
{ 
    unsigned a:1; 
    unsigned b:1; 
    unsigned c:1; 
    unsigned d:1; 
    unsigned e:1; 
    unsigned f:1; 
    unsigned g:1; 
    unsigned h:1; 
}; 

long get_bit_count( unsigned char b ) 
{
    struct _byte *by = (struct _byte*)&amp;amp;b; 
    return (by-&amp;gt;a+by-&amp;gt;b+by-&amp;gt;c+by-&amp;gt;d+by-&amp;gt;e+by-&amp;gt;f+by-&amp;gt;g+by-&amp;gt;h); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;求二进制最高位前0的个数&quot;&gt;&lt;a href=&quot;#求二进制最高位前0的个数&quot; class=&quot;headerlink&quot; title=&quot;求二进制最高位前0的个数&quot;&gt;&lt;/a&gt;求二进制最高位前0的个数&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;int nlz(unsigned x)
{
   int n;

   if (x == 0) return(32);
   n = 1;
   if ((x &amp;gt;&amp;gt; 16) == 0) {n += 16; x &amp;lt;&amp;lt;= 16;}
   if ((x &amp;gt;&amp;gt; 24) == 0) {n += 8; x &amp;lt;&amp;lt;= 8;}
   if ((x &amp;gt;&amp;gt; 28) == 0) {n += 4; x &amp;lt;&amp;lt;= 4;}
   if ((x &amp;gt;&amp;gt; 30) == 0) {n += 2; x &amp;lt;&amp;lt;= 2;}
   n = n - (x &amp;gt;&amp;gt; 31);
   return n;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;二进制逆序&quot;&gt;&lt;a href=&quot;#二进制逆序&quot; class=&quot;headerlink&quot; title=&quot;二进制逆序&quot;&gt;&lt;/a&gt;二进制逆序&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;int change(int x)
{
    x = (x &amp;amp; 0x55555555) &amp;lt;&amp;lt; 1 | (x &amp;amp; 0xAAAAAAAA) &amp;gt;&amp;gt; 1;
    x = (x &amp;amp; 0x33333333) &amp;lt;&amp;lt; 2 | (x &amp;amp; 0xCCCCCCCC) &amp;gt;&amp;gt; 2;
    x = (x &amp;amp; 0x0F0F0F0F) &amp;lt;&amp;lt; 4 | (x &amp;amp; 0xF0F0F0F0) &amp;gt;&amp;gt; 4;
    x = (x &amp;amp; 0x00FF00FF) &amp;lt;&amp;lt; 8 | (x &amp;amp; 0xFF00FF00) &amp;gt;&amp;gt; 8;
    x = (x &amp;amp; 0x0000FFFF) &amp;lt;&amp;lt; 16 | (x &amp;amp; 0xFFFF0000) &amp;gt;&amp;gt; 16;
    return x;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;位移求绝对值&quot;&gt;&lt;a href=&quot;#位移求绝对值&quot; class=&quot;headerlink&quot; title=&quot;位移求绝对值&quot;&gt;&lt;/a&gt;位移求绝对值&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;x xor (not (x shr 31) + 1) + x shr 31
x = x ^ ((~(x&amp;gt;&amp;gt;31))+1) + x&amp;gt;&amp;gt;31;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;交换二进制高16位和低16位&quot;&gt;&lt;a href=&quot;#交换二进制高16位和低16位&quot; class=&quot;headerlink&quot; title=&quot;交换二进制高16位和低16位&quot;&gt;&lt;/a&gt;交换二进制高16位和低16位&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;int change(int x)
{
   return (x &amp;gt;&amp;gt; 16) | (x &amp;lt;&amp;lt; 16);
   //byte可写成(x &amp;gt;&amp;gt; 4) | (x &amp;lt;&amp;lt; 4);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考链接：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.lijinma.com/blog/2014/05/29/amazing-xor/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.lijinma.com/blog/2014/05/29/amazing-xor/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现位运算在很多场合有很多运用啊。大概有以下几个方面:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;涉及二进制及其2^n进制的运算&lt;/li&gt;
&lt;li&gt;很少字段的struct class的改写例如棋盘记录和模式比较&lt;/li&gt;
&lt;li&gt;逼格&amp;amp;效率比较高的小心机&lt;/li&gt;
&lt;/ul&gt;

    
    </summary>
    
      <category term="代码狗" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="BitManipulattion" scheme="http://ovjaywang.github.io/tags/BitManipulattion/"/>
    
  </entry>
  
  <entry>
    <title>jQuery的三个坑</title>
    <link href="http://ovjaywang.github.io/2016/05/10/jQuery%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9D%91/"/>
    <id>http://ovjaywang.github.io/2016/05/10/jQuery的两个坑/</id>
    <published>2016-05-09T17:23:30.000Z</published>
    <updated>2016-05-19T17:13:19.000Z</updated>
    
    <content type="html">&lt;p&gt;许久没用jquery，今天碰到三个坑。小记一下&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;第一个是live()这个函数，在学习很早的资料，表示用来为被选元素附加一个或多个事件处理程序,形式为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;$(selector).live(event,data,function)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如为button绑定一个单击事件，event为事件名，data为可选的传参，function为自定义函数。&lt;br&gt;测了半天没开F12一直以为代码有问题，，后来一看原来jquery1.9+以上不支持live了。先改成了delegate代理，后来又改成on,真特么烦人。  &lt;/p&gt;
&lt;p&gt;应该值得注意到的是，改成on后，触发的事件在容器对象上，而live返回值在事件触发的对象上。&lt;br&gt;&lt;a href=&quot;http://jquery.com/upgrade-guide/1.9/#live-removed&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;是官方解释&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一直以为&lt;code&gt;$(selector)&lt;/code&gt;能抓到所有的id啊。。。原来好像dom树的id不能明明一样的。（但在1.4-版本测试是可以的，不知道是改进了对id选择器的定义和方法加载，明确了id唯一这个特征）&lt;br&gt;要对类似的组件操作类似的方法，例如对tr表单下的td采用同个样式，a使用类似的连接，可以使用&lt;code&gt;$(.class)&lt;/code&gt;的方式获取。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;jquery1.9+以后不支持.attr属性的设置了，改成了.prop .妈蛋啊怎么改这么多好烦啊简直排错都不知道什么bug&lt;br&gt;炸裂看看1.9+的&lt;a href=&quot;http://www.ppblog.cn/jquery1-9live.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;更新&lt;/a&gt;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;true false两个选项的属性用prop&lt;/li&gt;
&lt;li&gt;添加属性名称该属性就生效用prop&lt;/li&gt;
&lt;li&gt;其他可以用attr&lt;/li&gt;
&lt;/ol&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;许久没用jquery，今天碰到三个坑。小记一下&lt;br&gt;
    
    </summary>
    
      <category term="代码狗" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="jQuery" scheme="http://ovjaywang.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>树系列码集合[持更20160517]</title>
    <link href="http://ovjaywang.github.io/2016/05/03/%E6%A0%91%E7%B3%BB%E5%88%97%E7%A0%81%E9%9B%86%E5%90%88-%E6%8C%81%E6%9B%B4/"/>
    <id>http://ovjaywang.github.io/2016/05/03/树系列码集合-持更/</id>
    <published>2016-05-03T15:06:28.000Z</published>
    <updated>2016-05-19T17:13:19.000Z</updated>
    
    <content type="html">&lt;p&gt;本文持更树操作集合-码狗学习中&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二叉查找树转双链表（c-）&quot;&gt;&lt;a href=&quot;#二叉查找树转双链表（c-）&quot; class=&quot;headerlink&quot; title=&quot;二叉查找树转双链表（c++）&quot;&gt;&lt;/a&gt;二叉查找树转双链表（c++）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;需求就是一个二叉树查找树 ，要转成按顺序排列的双向链表&lt;/p&gt;
&lt;p&gt;思路差不多就是：中序可以按顺序输出；左儿子指针指向相邻小的，右儿子指针指向相邻大的；相邻由中序控制,左右儿子改动的时候寄存在pre(前驱)和root(当前)下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义模版类及head pre指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    template&amp;lt;class T&amp;gt;                  //模版结构体
    struct TreeNode
    {
        T data;                       //节点的内容
        TreeNode &amp;lt;T&amp;gt; *Lchild, *Rchild,*pParent; //节点的左子树和右子树
    //可选择参数的默认构造函数
    TreeNode(T nodeValue = T(), TreeNode&amp;lt;T&amp;gt; *leftNode = NULL, TreeNode&amp;lt;T&amp;gt; *rightNode = NULL, TreeNode&amp;lt;T&amp;gt; *parentNode = NULL)
    :data(nodeValue),Lchild(leftNode),Rchild(rightNode),pParent(parentNode){}
    };

    TreeNode&amp;lt;int&amp;gt; * pHead =NULL;//存放头指针
    TreeNode&amp;lt;int&amp;gt; * previous = NULL;//存放前驱
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;核心转换代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    template&amp;lt;class T&amp;gt;
    void Tranverse(TreeNode&amp;lt;T&amp;gt; * root)//记前序
    {
        if (root){
            Tranverse(root-&amp;gt;Lchild);//很明显的中序遍历阿！
            if (previous){
                if (!pHead){//这个if可以不写啊 只是为了记录头结点而已
                    pHead = previous;
                }
                previous-&amp;gt;Rchild = root;//前驱的右指针指向root
                root-&amp;gt;Lchild = previous;//root的左指针指向前驱
            }
            previous = root;//前驱跑到下一个更新
            Tranverse(root-&amp;gt;Rchild);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用代码,我才懒得写insert代码啊，rootNode从哪里来的我也不管啊&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c+&quot;&gt;    Tranverse(rootNode);
    while (pHead != NULL){
        cout &amp;lt;&amp;lt; pHead-&amp;gt;data &amp;lt;&amp;lt; endl;
        pHead = pHead-&amp;gt;Rchild;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码见&lt;a href=&quot;https://github.com/ovjaywang/TreeInvolved/tree/master/BSTree2DoubleLinkList&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;在二叉查找树里查找范围内数据-c&quot;&gt;&lt;a href=&quot;#在二叉查找树里查找范围内数据-c&quot; class=&quot;headerlink&quot; title=&quot;在二叉查找树里查找范围内数据(c++)&quot;&gt;&lt;/a&gt;在二叉查找树里查找范围内数据(c++)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;二叉查找树对于范围查找效率比普通线性查找效率高，Point仍旧是中序按序输出。&lt;/p&gt;
&lt;p&gt;思路：这次换一个c语言方式类typedef定义二叉树模版，以二叉按次序找到下限第一个，然后其后的数据与最大最小值比较，在范围内就输出。因此，在二叉查找树中序输出中中，加两个判断条件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入左子树需要根节点比最小值大  &lt;/li&gt;
&lt;li&gt;进入右子树需要根节点比最大值小&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;类模版定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;typedef int KeyType;
typedef struct TreeNode
{
    KeyType key;          //关键字
    struct TreeNode * left;   //左孩子指针
    struct TreeNode * right;  //右孩子指针
    struct TreeNode * parent; //指向父节点指针
}TreeNode, *PNode;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关键代码 以范围搜索&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;    set&amp;lt;KeyType&amp;gt; searchRange(KeyType min, KeyType max, set&amp;lt;KeyType&amp;gt; &amp;amp;vt, TreeNode *root){
        if (!root) return vt ;
        if (min &amp;lt; root-&amp;gt;key)
            searchRange(min, max, vt,root-&amp;gt;left);
        if (min &amp;lt;= root-&amp;gt;key &amp;amp;&amp;amp; max &amp;gt;= root-&amp;gt;key){
            vt.insert(root-&amp;gt;key);
        }
        if (max&amp;gt;root-&amp;gt;key)
            searchRange(min, max, vt,root-&amp;gt;right);
        return vt;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;    set&amp;lt;int&amp;gt; ss = set&amp;lt;int&amp;gt;();
    //很多地方都会把set带进函数迭代传递
    ss = searchRange(0, 3, ss, root);
    cout &amp;lt;&amp;lt; &amp;quot;vv.size() &amp;quot;&amp;lt;&amp;lt;ss.size()&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;&amp;quot;范围内包含节点有:&amp;quot;&amp;lt;&amp;lt;endl;
    for each (int item in ss)
    {
        cout &amp;lt;&amp;lt; item&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码见&lt;a href=&quot;https://github.com/ovjaywang/TreeInvolved/tree/master/FindInBSTree&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;输出-平衡-二叉树所有和为某值的路径&quot;&gt;&lt;a href=&quot;#输出-平衡-二叉树所有和为某值的路径&quot; class=&quot;headerlink&quot; title=&quot;输出(平衡)二叉树所有和为某值的路径&quot;&gt;&lt;/a&gt;输出(平衡)二叉树所有和为某值的路径&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;需求：一条路径就是从根到叶子所有节点，路径数就是叶子数。要输出所有满足路径上所有节点和为某值的路径。&lt;/p&gt;
&lt;p&gt;思路：为了保证效率，不能每次从头遍历到每个叶子才输出一次。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用栈压入根到当前节点的路径所有制，以便求和&lt;/li&gt;
&lt;li&gt;栈和超过值可以不继续寻找当前路径的儿子&lt;/li&gt;
&lt;li&gt;找一个儿子就在栈压入一个数值，跳回一个根就弹出一个儿子的值&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，我很无聊，试一试平衡二叉(AVL).平衡二叉防止了直接建立查找二叉时候的随机，保证了时间复杂式始终在log(n).但建立AVL时候的插入删除代价也相对较大。&lt;/p&gt;
&lt;p&gt;AVL模版类的声明，多了一个height（高度）属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    template &amp;lt;class T&amp;gt;
    class AVLTreeNode{
    public:
        T key;                // 关键字(键值)
        int height;         // 高度
        AVLTreeNode *left;    // 左孩子
        AVLTreeNode *right;    // 右孩子
        //构造函数
        AVLTreeNode(T value, AVLTreeNode *l, AVLTreeNode *r) :
            key(value), height(0), left(l), right(r) {}
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AVLtree类中包含了函数声明和一个&lt;code&gt;AVLTreeNode&amp;lt;T&amp;gt; *mRoot;&lt;/code&gt;作为根节点；一个public的函数&lt;code&gt;void SearchPath(const T value);&lt;/code&gt;给外部调用；一个private的函数&lt;code&gt;void SearchPath(AVLTreeNode&amp;lt;T&amp;gt;* root, T* seq, T top, T sumCount, const T value);&lt;/code&gt;作为自迭代的函数，传入当前节点指针，当前线性表指针，栈顶指针(栈压入的数目)，当前和以及目标值。&lt;/p&gt;
&lt;p&gt;关键代码，使用的是栈，但其实就是个顺序表，系统自动建立内存空间，每次进栈自增。&lt;br&gt;公有函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    template&amp;lt;class T&amp;gt;
    void AVLTree&amp;lt;T&amp;gt;::SearchPath(const T value){
        T * seq = new int[0];
        T sumCount = 0;//当前累积值
        T top = 0;
        return SearchPath(mRoot, seq, top, sumCount, value);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;私有函数  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    //遍历次序无所谓的 反正要遍历所有叶子
    template&amp;lt;class T&amp;gt;
    void AVLTree&amp;lt;T&amp;gt;::SearchPath(AVLTreeNode&amp;lt;T&amp;gt;* root, T* seq, T top, T sumCount, const T value)//按值传递回溯不用恢复参数值和栈顶  
    {
        seq[top++] = root-&amp;gt;key;//入栈
        sumCount += root-&amp;gt;key;//累加和
        //if(sumCount &amp;gt; value) return;//当值为正数时可加上这句话
        if (root-&amp;gt;left == NULL &amp;amp;&amp;amp; root-&amp;gt;right == NULL){//为叶子节点
            if (sumCount == value)
                for (int i = 0; i&amp;lt;top; i++)
                    cout &amp;lt;&amp;lt; seq[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        }
        else{
            if (root-&amp;gt;left)
                SearchPath(root-&amp;gt;left, seq, top, sumCount, value);
            if (root-&amp;gt;right)
                SearchPath(root-&amp;gt;right, seq, top, sumCount, value);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用代码  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    AVLTree&amp;lt;int&amp;gt;* tree = new AVLTree&amp;lt;int&amp;gt;();
    int const value = 16;//目标和
    tree-&amp;gt;SearchPath(value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码见&lt;a href=&quot;https://github.com/ovjaywang/TreeInvolved/tree/master/FindSumEqualNumInAVL&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;求树高的几种方式&quot;&gt;&lt;a href=&quot;#求树高的几种方式&quot; class=&quot;headerlink&quot; title=&quot;求树高的几种方式&quot;&gt;&lt;/a&gt;求树高的几种方式&lt;/h1&gt;&lt;p&gt;首先定义一波树结构属性名字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    typedef struct TreeNode{
        char data;
        struct TreeNode *lchild, *rchild;
    }TreeNode, *BiTree;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;后序遍历，栈求高，最大栈长度为树高&quot;&gt;&lt;a href=&quot;#后序遍历，栈求高，最大栈长度为树高&quot; class=&quot;headerlink&quot; title=&quot;后序遍历，栈求高，最大栈长度为树高&quot;&gt;&lt;/a&gt;后序遍历，栈求高，最大栈长度为树高&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思路：进左右子则入栈，返回根节点则出栈。每次左右子树检查完毕就比较一次栈长度是否大于最大高度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    int BT_high(BiTree T){
        BiTree p = T, r = NULL;
        int max = 0;//记录最大树高  
        stack&amp;lt;BiTree&amp;gt; s;//声明一个堆 存放树根节点
        while (p || !s.empty()){//节点非空且堆栈非空
            if (p != NULL){
                s.push(p);//入栈
                p = p-&amp;gt;lchild;
            }
            else{
                p = s.top();
                if (p-&amp;gt;rchild != NULL &amp;amp;&amp;amp; p-&amp;gt;rchild != r)
                //判断是否从右子树返回根
                    p = p-&amp;gt;rchild;
                else{//左右子树都算完了 比较一下
                    if (s.size()&amp;gt;max) max = s.size();//最大层次即为高度  
                    r = p;
                    s.pop();//出栈
                    p = NULL;
                }
            }
        }
        return max;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;层次遍历-层高即树高&quot;&gt;&lt;a href=&quot;#层次遍历-层高即树高&quot; class=&quot;headerlink&quot; title=&quot;层次遍历 层高即树高&quot;&gt;&lt;/a&gt;层次遍历 层高即树高&lt;/h2&gt;&lt;p&gt;层次遍历服用队列或堆栈效果更佳！  &lt;/p&gt;
&lt;h3 id=&quot;层次遍历-单数组&quot;&gt;&lt;a href=&quot;#层次遍历-单数组&quot; class=&quot;headerlink&quot; title=&quot;层次遍历-单数组&quot;&gt;&lt;/a&gt;层次遍历-单数组&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;思路：按层将树输入到数组，下标记下本层元素头尾，从头遍历到尾加入它们的儿子，不断循环&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;int BT_level_depth(BiTree T)
{
    if (!T)  return 0;
    BiTree p = T, Q[100];//队列
    int front = -1, rear = -1, last = 0, level = 0;
    //定义首指针 尾指针 上层尾元素 当前高度
    Q[++rear] = p;//入队列
    while (front&amp;lt;rear){
        p = Q[++front];//先设置本次循环的根
        if (p-&amp;gt;lchild)//加入根的左儿子 同时移动尾
            Q[++rear] = p-&amp;gt;lchild;
        if (p-&amp;gt;rchild)//加入根的右儿子 同时移动尾
            Q[++rear] = p-&amp;gt;rchild;
        if (front == last){//当头指针遍历完本层所有元素
            last = rear;
            level++;//层次+1  
        }
    }
    return level;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;层次遍历-双端队列&quot;&gt;&lt;a href=&quot;#层次遍历-双端队列&quot; class=&quot;headerlink&quot; title=&quot;层次遍历-双端队列&quot;&gt;&lt;/a&gt;层次遍历-双端队列&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;思路：按层将树输入到双端队列，一个队列记录上一层所有节点，另一个队列加入所有另一个队列的儿子，不断交替。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;int BT_level_depth222(BiTree T)
{
    int  max = 0;
    deque&amp;lt;TreeNode*&amp;gt; q_first, q_second;
    q_first.push_back(T);
    while (!q_first.empty()) {
        while (!q_first.empty()) {
            TreeNode *temp = q_first.front();
            q_first.pop_front();
            cout &amp;lt;&amp;lt; (int)temp-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            if (temp-&amp;gt;lchild)
                q_second.push_back(temp-&amp;gt;lchild);
            if (temp-&amp;gt;rchild)
                q_second.push_back(temp-&amp;gt;rchild);
        }
        cout &amp;lt;&amp;lt; endl;
        max++;
        q_first.swap(q_second);
    }
    return max;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;递归求树高&quot;&gt;&lt;a href=&quot;#递归求树高&quot; class=&quot;headerlink&quot; title=&quot;递归求树高&quot;&gt;&lt;/a&gt;递归求树高&lt;/h2&gt;&lt;h3 id=&quot;后序递归带深度求高&quot;&gt;&lt;a href=&quot;#后序递归带深度求高&quot; class=&quot;headerlink&quot; title=&quot;后序递归带深度求高&quot;&gt;&lt;/a&gt;后序递归带深度求高&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;思路:后序遍历所有节点，递归调用并检查当前节点是否为最大值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;int max1 = 0;//树高  
int BT_depth1(BiTree T, int depth)
{
    if (T)
    {
        if (T-&amp;gt;lchild)
            BT_depth1(T-&amp;gt;lchild, depth + 1);
        if (T-&amp;gt;rchild)
            BT_depth1(T-&amp;gt;rchild, depth + 1);
    }
    if (depth&amp;gt;max1)
        max1 = depth;
    return depth;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;左右子树递归求树高&quot;&gt;&lt;a href=&quot;#左右子树递归求树高&quot; class=&quot;headerlink&quot; title=&quot;左右子树递归求树高&quot;&gt;&lt;/a&gt;左右子树递归求树高&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;思路： 求左右子树的高度，分别又把左右子树当做根求他们的子树。每次迭代返回当前左右子树高的那一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;int Height(BiTree T)
{
    if (T == NULL) return 0;
    else
    {
        int m = Height(T-&amp;gt;lchild);
        int n = Height(T-&amp;gt;rchild);
        return (m &amp;gt; n) ? (m + 1) : (n + 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码见&lt;a href=&quot;https://github.com/ovjaywang/TreeInvolved/tree/master/GetMaxDepth&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;本文持更树操作集合-码狗学习中&lt;br&gt;
    
    </summary>
    
      <category term="代码狗" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="code" scheme="http://ovjaywang.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Svm初探</title>
    <link href="http://ovjaywang.github.io/2016/04/28/svm%E5%88%9D%E6%8E%A2/"/>
    <id>http://ovjaywang.github.io/2016/04/28/svm初探/</id>
    <published>2016-04-28T14:26:41.000Z</published>
    <updated>2016-04-28T16:36:57.000Z</updated>
    
    <content type="html">&lt;p&gt;待更……&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;待更……&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Effective Java 笔记--创建对象的几个Tips</title>
    <link href="http://ovjaywang.github.io/2016/04/27/effective-java-tips-of-create-object/"/>
    <id>http://ovjaywang.github.io/2016/04/27/effective-java-tips-of-create-object/</id>
    <published>2016-04-27T03:50:01.000Z</published>
    <updated>2016-08-30T13:32:36.000Z</updated>
    
    <content type="html">&lt;p&gt;第一章-创建和销毁对象 的一些 小tips&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;不希望被实例化-又不想抽象化&quot;&gt;&lt;a href=&quot;#不希望被实例化-又不想抽象化&quot; class=&quot;headerlink&quot; title=&quot;不希望被实例化 又不想抽象化&quot;&gt;&lt;/a&gt;不希望被实例化 又不想抽象化&lt;/h1&gt;&lt;p&gt;某些类不希望被实例化出毫无意义的对象 但不编写显示构造器类会自定义一个隐式无参的构造器 因此可以用一下方式，编写不能实例化的类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;
  public class UtilityClass{
    private UtilityClass(){
      throw new AssertionError();//直接抛出assert验证异常 好坏
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该构造器是私有的。其他类不能过访问（即使同包）。&lt;/p&gt;
&lt;h1 id=&quot;不要创建没必要的对象&quot;&gt;&lt;a href=&quot;#不要创建没必要的对象&quot; class=&quot;headerlink&quot; title=&quot;不要创建没必要的对象&quot;&gt;&lt;/a&gt;不要创建没必要的对象&lt;/h1&gt;&lt;p&gt;不可变的对象一定要重用（singleton）；重用绝逼不会变的对象（例如计时初始时间、例如物种的属性）。例如，实例化Person对象的时候判断是不是计划生育年代出生的，即判断出生年份是否在1983-2015年。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Person{
   private final Date birthDate;
   private static final Date BIRTH_START;
   //这俩参数都是不变的 为了对比出生时间 
   //没必要每次都创建一个日期对象，只在初始化时调用。
   private static final Date BIRTH_END; 

//静态块的方法 第一次声明Person对象时构建（不用实例化）
// 后面占用一块内存 不用再次创建
   static{
        Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(&amp;quot;GMT&amp;quot;));
        gmtCal.set(1983,Calendar.JANUARY,1,0,0,0);
        //这里对日期做了时区判断 
        //保证都是从某一客观时间点出生的
        BIRTH_START = gmtCal.getTime();
        gmtCal.set(2016,Calendar.JANUARY,1,0,0,0);
        //截止2015年年底 所以取2016年年初
        BIRTH_END = gmtCal.getTime();
   }

    public boolean isJiHuaShengYu(){
        return birthDate.compareTo(BIRTH_START) &amp;gt;=0 &amp;amp;&amp;amp;
            birthDate.compareTo(BIRTH_END) &amp;lt;=0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果isJiHuaShengYu方法&lt;font color=&quot;red&quot;&gt;从未调用&lt;/font&gt;，这个方法就显得不合时宜了，这块静态块的内存就一直占着，因此，可以采用延时初始化的方式，在第一次调用该方法时调用。&lt;/p&gt;
&lt;p&gt;adapter适配器模式可以提供一个后备对象，使实例化次数减少（包括类适配器和对象适配器）；autoboxing自动装箱模式能够自动创建多余对象，所以尽量少用，而使用基本数据类型。&lt;/p&gt;
&lt;h2 id=&quot;适配器Adapter&quot;&gt;&lt;a href=&quot;#适配器Adapter&quot; class=&quot;headerlink&quot; title=&quot;适配器Adapter&quot;&gt;&lt;/a&gt;适配器Adapter&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;adapter工作场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;适配器模式工作场景是：给定的一个接口不满足需求，需要其一些功能与其他的接口或类配合使用.正如已经给了电压和充电插座，但是插座电压与设备工作电压，这是时候就需要一个转换接头。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adapter分类 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般分为类适配器和对象适配器。&lt;strong&gt;类适配器&lt;/strong&gt;一般继承了给定接口的被适配类，同时拓展实现了标准的接口；而&lt;strong&gt;对象适配器&lt;/strong&gt;则直接关联，以委托的方式完成已知接口的特殊功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;类适配器实例：Adaptee（已知的待适配的类） Target（目标类） Adapter（适配器类）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，类适配器的方式通过继承或实现接口的方式，来传递某些功能或方法，以达到利用已知功能的目的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;
    // 已存在的、具有特殊功能、但不符合我们既有的标准接口的类
class Adaptee {
    public void specificRequest() {
        System.out.println(&amp;quot;被适配类具有 特殊功能...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;
// 目标接口，或称为标准接口
interface Target {
    public void request();
}

// 具体目标类，只提供普通功能
class ConcreteTarget implements Target {
    public void request() {
        System.out.println(&amp;quot;普通类 具有 普通功能...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;
// 适配器类，继承了被适配类，同时实现标准接口
class Adapter extends Adaptee implements Target{
    public void request() {
        super.specificRequest();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;
// 测试类
    public class Client {
        public static void main(String[] args) {
            // 使用普通功能类
            Target concreteTarget = new ConcreteTarget();
            concreteTarget.request();

            // 使用特殊功能类，即适配类
            Target adapter = new Adapter();
            adapter.request();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;对象适配器实例 Adapter适配器类 被适配器同上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对象适配器则通过对被适配类实例化，通过其对象获取其中部分功能，委托这一实例来完成想要传递的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
// 适配器类，直接关联被适配类，同时实现标准接口
class Adapter implements Target{
    // 直接关联被适配类
    private Adaptee adaptee;

    // 可以通过构造函数传入具体需要适配的被适配类对象
    public Adapter (Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    public void request() {
        // 这里是使用委托的方式完成特殊功能
        this.adaptee.specificRequest();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;
public class Client {
    public static void main(String[] args) {
        // 使用普通功能类
        Target concreteTarget = new ConcreteTarget();
        concreteTarget.request();

        // 使用特殊功能类，即适配类，
        // 需要先创建一个被适配类的对象作为参数
        Target adapter = new Adapter(new Adaptee());
        adapter.request();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考&lt;a href=&quot;http://haolloyin.blog.51cto.com/1177454/346128&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;autoboxing方式&lt;/p&gt;
&lt;/blockquote&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;第一章-创建和销毁对象 的一些 小tips&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo多客户端写作</title>
    <link href="http://ovjaywang.github.io/2016/04/27/hexo%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%86%99%E4%BD%9C/"/>
    <id>http://ovjaywang.github.io/2016/04/27/hexo多客户端写作/</id>
    <published>2016-04-27T03:50:01.000Z</published>
    <updated>2016-04-28T17:37:37.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Hexo是很棒的静态博客，简单的安装配置即可专注写作。&lt;br&gt;但是强迫症就是很爱折腾。倘若：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机烧了数据备份怎么破？&lt;/li&gt;
&lt;li&gt;换了系统想继续之前的写作怎么破?&lt;/li&gt;
&lt;li&gt;纯粹就是想多客户端写作怎么破？&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;我就纯属蛋疼的。喜欢在办公和休息的地方都写作；或者我一win本&lt;br&gt;一mac 都想写文章。但Hexo的静态部署的原则不像WordPress一样，能关联博客地址，利用数据库进行博客更新。好了，这里就来解决这个问题。┑(￣Д ￣)┍&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Hexo写作的部署逻辑-amp-其他&quot;&gt;&lt;a href=&quot;#Hexo写作的部署逻辑-amp-其他&quot; class=&quot;headerlink&quot; title=&quot;Hexo写作的部署逻辑&amp;amp;其他&quot;&gt;&lt;/a&gt;Hexo写作的部署逻辑&amp;amp;其他&lt;/h1&gt;&lt;h2 id=&quot;Hexo的写作特点&quot;&gt;&lt;a href=&quot;#Hexo的写作特点&quot; class=&quot;headerlink&quot; title=&quot;Hexo的写作特点&quot;&gt;&lt;/a&gt;Hexo的写作特点&lt;/h2&gt;&lt;p&gt;Hexo最大特点就是静态博客，即部署到服务器的博客内容是静态写好的html（由markdown转义），而不像类似wordpress的数据都存放在服务器端数据库，每次更新即一次读写数据库的操作。所以如果需要更改博客内容、发布新内容，必须&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;更改源文件source文件夹下_post及其他各页面文件夹的md文件&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;hexo g&lt;/code&gt;或&lt;code&gt;hexo generate&lt;/code&gt;在public生成静态文件。&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;hexo-deployer-git&lt;/code&gt;插件及&lt;code&gt;hexo d&lt;/code&gt;命令将public的文件自动的部署到创建好的&lt;code&gt;user-name.github.io&lt;/code&gt;项目中。&lt;blockquote&gt;
&lt;p&gt;在github项目中可以看到，自动上传的只有public文件夹中的文件，包括以年份分类的静态页面文件夹、tag、categories及其他辅助css、js、img等，还有域名指引的CNAME和rss sitemap等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;在博客中看到更新的内容。当然，本地目录中，即存放了md源文件，也包含了生成的public文件。其实，本地并不需要public里的内容，只要有写作的源文件，generate一下就能生成。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Hexo的缺憾&quot;&gt;&lt;a href=&quot;#Hexo的缺憾&quot; class=&quot;headerlink&quot; title=&quot;Hexo的缺憾&quot;&gt;&lt;/a&gt;Hexo的缺憾&lt;/h2&gt;&lt;p&gt;那么问题来了，如果我在公司和贫民窟都想写作怎么办。总不能在两个本地仓库hexo init都部署到pages项目。在公司更新一篇blog里面全都是公司写的，然后回到地下室又写一篇更新又全是小黑屋的内容。  &lt;/p&gt;
&lt;p&gt;尽管Hexo让人专注写作，随时随地用md写一篇博，等到来到同步的机器才更新一次也让人很不爽。对于远程仓库只存放静态文件的方案，就想到了两个思路&lt;/p&gt;
&lt;h3 id=&quot;同步静态文件&quot;&gt;&lt;a href=&quot;#同步静态文件&quot; class=&quot;headerlink&quot; title=&quot;同步静态文件&quot;&gt;&lt;/a&gt;同步静态文件&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;新仓库同步静态文件-&amp;gt;hexo g生成静态文件-&amp;gt;合并静态文件-&amp;gt;hexo d部署&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在两地分别hexo init建立hexo博客目录，在_config.yml中都部署到同一个远程仓库，在每次generate时，都先将远程仓库的静态文件同步下来（新建一个单独的folder专门用于同步静态文件）。请勿使用hexo博客中的public文件夹用于同步，每次generate会覆盖同名文件。若另一台主机曾做过修改并提交，这次修改的静态文件将被本地未修改的静态文件覆盖。具体操作：&lt;br&gt;第一次克隆远程hexo主分支：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git clone git@github.com:user-name/user-name.github.io.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后每次hexo仓库发布首先在静态文件仓库获取远程仓库最新静态文件(无条件merge)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull origin master
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;在静态文件同步仓库中，将自上次部署后，本地修改过的静态文件&lt;strong&gt;删掉&lt;/strong&gt;（不记得怪我咯┑(￣Д ￣)┍）；同时在hexo blog仓库中&lt;code&gt;hexo -g&lt;/code&gt;生成本地静态文件。&lt;/li&gt;
&lt;li&gt;将剔除过期静态文件的public仓库中文件复制到hexo的public中。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;hexo -d&lt;/code&gt;部署&lt;blockquote&gt;
&lt;p&gt;以上步骤2中的删除操作是为了保证静态文件的数据都是最新的，保证博客内容的一致性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;同步源文件（大招）&quot;&gt;&lt;a href=&quot;#同步源文件（大招）&quot; class=&quot;headerlink&quot; title=&quot;同步源文件（大招）&quot;&gt;&lt;/a&gt;同步源文件（大招）&lt;/h3&gt;&lt;p&gt;想到上述方式需要进行2步骤的主要原因就是本地的源文件不同步，只能通过生成的静态文件进行合并的方式，为毛不将源文件同步呢？！参考&lt;a href=&quot;http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;的思路，同步源文件就是通过远程仓库对源文件融合统一。&lt;/p&gt;
&lt;h2 id=&quot;呵呵哒&quot;&gt;&lt;a href=&quot;#呵呵哒&quot; class=&quot;headerlink&quot; title=&quot;呵呵哒&quot;&gt;&lt;/a&gt;呵呵哒&lt;/h2&gt;&lt;p&gt;本文为了完成多客户端的同Hexo博的管理和发布，对ssh、git安装、Hexo安装、配置插件主题管理、域名绑定&lt;strong&gt;不涉及&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统不限制 &lt;/li&gt;
&lt;li&gt;是否写过博部署过没差&lt;/li&gt;
&lt;li&gt;最好Hexo3.X,2.X没试过出事自负&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;真·多客户端&quot;&gt;&lt;a href=&quot;#真·多客户端&quot; class=&quot;headerlink&quot; title=&quot;真·多客户端&quot;&gt;&lt;/a&gt;真·多客户端&lt;/h1&gt;&lt;h2 id=&quot;创建远程仓库&quot;&gt;&lt;a href=&quot;#创建远程仓库&quot; class=&quot;headerlink&quot; title=&quot;创建远程仓库&quot;&gt;&lt;/a&gt;创建远程仓库&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对于没有进行创作的hexo博客，首先创建同名仓库，再创建一个hexo branch。此时俩分支都是空的  &lt;/li&gt;
&lt;li&gt;对于已经进行创作的hexo博客，直接创建一个hexo 分支。此时，hexo clone了master的静态文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;设置主分支&quot;&gt;&lt;a href=&quot;#设置主分支&quot; class=&quot;headerlink&quot; title=&quot;设置主分支&quot;&gt;&lt;/a&gt;设置主分支&lt;/h2&gt;&lt;p&gt;将hexo branch设为主分支，用于同步源文件；master branch作为静态文件的存放。（由于github pages会检索master分支作为该域名下的部署分支，因此必须把master名字保留）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/04/27/5720a2a70a238.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;同步远程仓库并初始化&quot;&gt;&lt;a href=&quot;#同步远程仓库并初始化&quot; class=&quot;headerlink&quot; title=&quot;同步远程仓库并初始化&quot;&gt;&lt;/a&gt;同步远程仓库并初始化&lt;/h2&gt;&lt;p&gt;在本地（包含第一次所有源文件的主机）新建一个文件夹（就算已经写过博客的也这么搞）同步远程仓库并初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git@github.com:your-Id/your-Id.github.io.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时输入&lt;code&gt;git branch&lt;/code&gt;可以看到两个分支，红色分支为主分支。&lt;br&gt;若是非空白博客，同步后需要先删掉里面的静态文件.直接删光，把原博客的文件全部复制过来&lt;strong&gt;（好像没有发现更换远程仓库主分支后本地同步更换的git bash。求解?）&lt;/strong&gt;;若是空白博客，那么需要再令建一个文件夹，（因为hexo init操作会覆盖原.git文件导致与远程仓库失联）在该文件夹git bash执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g hexo
hexo init
npm install
hexo g
npm install hexo-deployer-git--save
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了，里面该有的差不多都有了。全部复制到源文件仓库。&lt;strong&gt;注意把hello worl删掉啊。&lt;/strong&gt;关键的就是，config.yml里deployer的branch是master，而本地仓库关联的是hexo就对了。&lt;br&gt;然后执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;init&amp;quot;
git push -u origin hexo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，有的时候提示主题的文件夹并未加入同步操作，显示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;
Changes not staged for commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即主题文件夹的内容尚未有之前版本，应该加入tracked。应在提交前输入&lt;code&gt;git add themes/themes_name/&lt;/code&gt;.最后那个斜杠别忘了加。&lt;br&gt;这就完成源文件的同步了！(￣▽￣)”” 执行&lt;code&gt;hexo d&lt;/code&gt;操作将本地public静态文件部署。&lt;/p&gt;
&lt;h1 id=&quot;发博日常&quot;&gt;&lt;a href=&quot;#发博日常&quot; class=&quot;headerlink&quot; title=&quot;发博日常&quot;&gt;&lt;/a&gt;发博日常&lt;/h1&gt;&lt;h2 id=&quot;更博&quot;&gt;&lt;a href=&quot;#更博&quot; class=&quot;headerlink&quot; title=&quot;更博&quot;&gt;&lt;/a&gt;更博&lt;/h2&gt;&lt;p&gt;如果你不能确定是否抽风需要经常换客户端，因此需要每次都要同步本地源文件；如果能忍住，，或者有规律的换客户端，那么平时更新不需要经常同步。&lt;br&gt;写博前操作(&lt;strong&gt;特么狠重要啊&lt;/strong&gt;)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull origin hexo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更新操作：(同步源文件到hexo分支)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;quot;hehe&amp;quot;
git push origin hexo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样每次更博都需要多几个步骤，嫌麻烦就要忍住不手痒了。在手机、pad写md再同步到电脑也是个不错的习惯。&lt;/p&gt;
&lt;h2 id=&quot;换客户端&quot;&gt;&lt;a href=&quot;#换客户端&quot; class=&quot;headerlink&quot; title=&quot;换客户端&quot;&gt;&lt;/a&gt;换客户端&lt;/h2&gt;&lt;p&gt;easy.只要远程仓库存在了一份完整的源文件，那同步就很容易了。似上步第一次同步，使用&lt;code&gt;git clone git@github.com:your-Id/your-Id.github.io.git&lt;/code&gt;拷贝仓库。然后执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g hexo
npm install
npm install hexo-deployer-git
&lt;/code&gt;&lt;/pre&gt;&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;不用hexo init!!!&lt;/strong&gt;&lt;/font&gt;

&lt;h1 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h1&gt;&lt;h2 id=&quot;多地部署&quot;&gt;&lt;a href=&quot;#多地部署&quot; class=&quot;headerlink&quot; title=&quot;多地部署&quot;&gt;&lt;/a&gt;多地部署&lt;/h2&gt;&lt;p&gt;pacman的公式和代码支持好差啊~还有需要多地备份的可以尝试coding（page之前免费的现在要钱了 = =）.在站点部署文件中更改deploy：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;deploy:
   type: git
   repo: 
      github: https://github.com/{YOUR_ID}/{YOUR_ID}.github.io.git,master
      coding: https://git.coding.net/{YOUR_ID}/{BLOG　NAME}.git,master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同理也能部署到自己的ftp服务器上。&lt;/p&gt;
&lt;h2 id=&quot;bug1-file-name-too-long&quot;&gt;&lt;a href=&quot;#bug1-file-name-too-long&quot; class=&quot;headerlink&quot; title=&quot;bug1 file-name-too-long&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;bug1 file-name-too-long&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;在拷贝原始数据的时候，提交远程仓库时可能会报modules的文件夹无法同步。这个情况在windows下安装msysgit进行git bash会报这一问题。&lt;a href=&quot;https://github.com/msysgit/git/pull/110&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;也提到了这个异常。但这并不是git的问题，而是msysgit的问题。使用其他git方式对文件路径较长的提交就不会报错。实测在github for windows下提交该modules文件就不会报错。&lt;/p&gt;
&lt;h2 id=&quot;bug2-could-not-read-Username-for-‘https-XXX‘&quot;&gt;&lt;a href=&quot;#bug2-could-not-read-Username-for-‘https-XXX‘&quot; class=&quot;headerlink&quot; title=&quot;bug2 could not read Username for ‘https://XXX‘&quot;&gt;&lt;/a&gt;&lt;font color=&quot;red&quot;&gt;bug2 could not read Username for ‘&lt;a href=&quot;https://XXX&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://XXX&lt;/a&gt;‘&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;当需要推送另一台设备的静态文件时，可能极少情况会碰上这个问题。有的说是bash的版本问题，不识别这种方式的推送。然而我用的同一版本的msysgit..&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://stackoverflow.com/questions/20871549/error-when-push-commits-with-github-fatal-could-not-read-username&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;也发现了这个问题，尝试了一下使用在https中加入用户名和密码的方式能够良好的推送。。当然配置文件别泄露了。。更改配置文件的deploy如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;deploy:
   type: git
   repo: 
      github: https://{YOUR_ID}:{Your_Pwd}@github.com/{YOUR_ID}/{YOUR_ID}.github.io.git,master
      coding: https://{YOUR_ID}:{Your_Pwd}@git.coding.net/{YOUR_ID}/{BLOG　NAME}.git,master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Enjoy Hexo!&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hexo是很棒的静态博客，简单的安装配置即可专注写作。&lt;br&gt;但是强迫症就是很爱折腾。倘若：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机烧了数据备份怎么破？&lt;/li&gt;
&lt;li&gt;换了系统想继续之前的写作怎么破?&lt;/li&gt;
&lt;li&gt;纯粹就是想多客户端写作怎么破？&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;我就纯属蛋疼的。喜欢在办公和休息的地方都写作；或者我一win本&lt;br&gt;一mac 都想写文章。但Hexo的静态部署的原则不像WordPress一样，能关联博客地址，利用数据库进行博客更新。好了，这里就来解决这个问题。┑(￣Д ￣)┍&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Effective Java--Builer构造器</title>
    <link href="http://ovjaywang.github.io/2016/04/22/effective%20java--builer%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <id>http://ovjaywang.github.io/2016/04/22/effective java--builer构造器/</id>
    <published>2016-04-22T09:10:48.000Z</published>
    <updated>2016-05-19T17:13:19.000Z</updated>
    
    <content type="html">&lt;p&gt;一个实体类往往有不同的属性 属性有的用于构造器 视为构造时的必需参数 而有的可有可无 类似json和xml一般，有多少个属性，每个属性有多少个赋值都不确定 。e.g.动物 名称string name和是否有尾巴istail是必须的，是否吃草iseatgrass 多重weight 交配手段sexmethod 科目等为非必须字段。解决这一构造问题一般有三种方式。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以采用不同的构造函数，一般的，把调用最多的构造出来，其余的按字段个数构造1-n个。诚然，有的字段并不需要，可能赋为空或者0。这样严重的影响了效率，同时字段多时构造函数也异常的多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;采用类似c#的方式 采用一个空字段构造器，使用setter和getter赋值和取值。这样的好处避免了过度的编写构造函数。但是在异步交互中，不能保证该对象的正确性和一致性。因此很可能需要冷冻。例如，名字叫草泥马的动物，是不具有排卵受精的性爱方式的。这样的setter不能及时维护数据的统一。又或者必须给予字段的动物名字和是否有尾巴在构造中并未赋值，造成的结果很可能在后面的调用中无法get到对应属性报异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;强悍的builder.在实体类中，再编写一个builder用于构造和赋值，必须的字段出现在构造函数中，需要赋值的字段在后面以.setter的方式调用，相当简洁高效，同时易于观察和修正。类似jQuery和python中一样。棒呆。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最丑的长字段实体类原本是这么写的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Animal{
    private string name;//必须参数
    private bool isTail;//必须参数
    private bool isEatGrass;//可选参数
    private double weight;//可选参数
    privaet int sexMethod;//可选参数

    Animal(string name,bool isTail)//这两个字段我特么就想要{
        this.name = name;
        this.isTail = isTail;
    }
    Animal(string name,bool isTail)//这两个字段我特么就想要{
        this.name = name;
        this.isTail = isTail;
    }
    Animal(string name,bool isTail,bool isEatGrass){
        this.name = name;
        this.isTail = isTail;
        this.isEatGrass = isEatGrass;
    }
    Animal(string name,bool isTail,bool isEatGrass,double weight){
        this.name = name;
        this.isTail = isTail;
        this.isEatGrass = isEatGrass;
        this.weight = weight;
    }
    Animal(string name,bool isTail,bool isEatGrass,double weight,int sexMe){
        this.name = name;
        this.isTail = isTail;
        this.isEatGrass = isEatGrass;
        this.weight = weight;
        this.sexMethon = sexMe;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在某处调用就可能是这样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Animal animal = new Animal(&amp;quot;caonima&amp;quot;,true,true,-1,3);
//由于我并不想知道体重，但又因为构造函数的关系不得不加上。
//所以相当繁琐。当字段达到几十个时，调用构造函数都分不清参数是否对应上。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​将上文的动物实体类以builder的方式写出来，大概是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Animal{
    private final string name;
    private final bool isTail;
    private final bool isEatGrass;
    private final double weight;
    private final int sexMethod;

    public static class Builder{//类内嵌套的静态类，可以通过类名的类名调用构造函数
        private final string name;
        //注意这里 final只对必需字段定义 表明不可修改 区分不同对象
        private final bool isTail;
        //给非必需字段设置默认值
        private bool isEatGrass =false;
        private double weight = 0.0;
        privaet int sexMethod =1;
        public Builder(string name,bool isTail){
            //构造函数只取必需字段
            this.name = name;
            this.isTail = isTail;
        }
        public Builder setISEatGrass(bool isEatGrass){
            this.isEatGrass = isEatGrass;
            return this;
        }
        public Builder setISEatGrass(double weight){
            this.weight = weight;
            return this;
        }
        public Builder setSexMethod(int sexMetho){
            this.sexMetho = sexMetho;
            return this;
        }

        public Animal build(){//在builder类内声明一个构造器 返回animal对象
            return new Animal(this);
        }
    }
    //当然 在animal类的最后 也需要把builder的参数取出来
    private Animal(Builder builder){
        name = builder.name;
        isTail = builder.isTail;
        isEatGrass = builder.isEatGrass;
        weigth = builder.weigth;
        sexMethod = builder.sexMethod;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在某处构造该类对象时，即可像下面一样声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Animal dog = new Animal.Builder(&amp;quot;旺财&amp;quot;,true).setIsEatGrass(false).setSexMethod(3).setWeight(20.0)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;builder类似一个抽象工厂 客户端可以将这样一个builder传给方法，在方法中生成需要数量的对象。1.5+版本可以使用泛型定义。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Builder{
    public T build();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在类似生成二叉树，kd树的时候，往往用户只需要将数据push进入，然后调用一个builder整棵树就构造好了。这种方式往往类似于带限制通配符类型的builder.&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;还有一点值得注意的是，新增字段时，不比增加更多的构造函数 ！&lt;/p&gt;
&lt;p&gt;caution!&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;增加了类长度，当字段较多时才较好的使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建对象首先得创建构造器，在强调性能的地方会比较麻烦。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;一个实体类往往有不同的属性 属性有的用于构造器 视为构造时的必需参数 而有的可有可无 类似json和xml一般，有多少个属性，每个属性有多少个赋值都不确定 。e.g.动物 名称string name和是否有尾巴istail是必须的，是否吃草iseatgrass 多重weight 交配手段sexmethod 科目等为非必须字段。解决这一构造问题一般有三种方式。&lt;br&gt;
    
    </summary>
    
      <category term="代码狗" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="java" scheme="http://ovjaywang.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>删除Sdf文件导致转到定义失效</title>
    <link href="http://ovjaywang.github.io/2016/04/22/what-the-hell-of-sdf/"/>
    <id>http://ovjaywang.github.io/2016/04/22/what-the-hell-of-sdf/</id>
    <published>2016-04-22T08:38:11.000Z</published>
    <updated>2016-04-28T16:36:57.000Z</updated>
    
    <content type="html">&lt;p&gt;cmomit的时候发现一个&lt;strong&gt;.sdf&lt;/strong&gt;的文件特别大，项目才不到2m，一个sdf就30多m了。能不能删？&lt;br&gt;谷歌了一下，提示sdf文件和iph文件是存放预编译头和Intellisense的。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;预编译头是 c++下的.h和.hpp等需要调用的文件头&lt;br&gt;Intellisense是自动补齐和代码检测的文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;巨硬在&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/hcw1s69b.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;也给出了Intellisense的强大功效。&lt;/p&gt;
&lt;p&gt;在工具-&amp;gt;选项-&amp;gt;文本编辑器-&amp;gt;C/C++-&amp;gt;高级-&amp;gt;禁用数据库改为true。的确就能不生成了。&lt;br&gt;怒删了。居然?调试的时候转到定义（F12）失效了。自动补全和错误更正失效了。该选项的第一个表单Intellisense居然全都不能改变了。。。那么问题来了。我每次commit都需要删掉。然后每次又给我生成。烦躁。&lt;/p&gt;
&lt;p&gt;search到很多F12失效和类名找不到的，都很有可能是这个问题。即使，再次把禁用数据库false掉、把 工具-&amp;gt;选项-&amp;gt;项目和解决方案-&amp;gt;常规-&amp;gt;在解决方案资源管理器中跟踪活动项 反复勾选也没有用。呵呵哒。好险回收站里的sdf文件没有删。同时，这一更改在别的工程不会影响，只要sdf在就没事。&lt;/p&gt;
&lt;p&gt;解决方案：尝试每次删简直繁琐。在选项禁用数据库上面，可以改正sdf文件的存放位置。将始终使用退回位置设为true，把sdf删掉。使用一个每次不需要同步的文件夹，编译调试时能使用，又不影响git速度，棒呆。&lt;br&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/04/22/5719e9865cfc6.png&quot; alt=&quot;haha&quot;&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;cmomit的时候发现一个&lt;strong&gt;.sdf&lt;/strong&gt;的文件特别大，项目才不到2m，一个sdf就30多m了。能不能删？&lt;br&gt;谷歌了一下，提示sdf文件和iph文件是存放预编译头和Intellisense的。&lt;br&gt;
    
    </summary>
    
      <category term="什么都学一下" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="c++" scheme="http://ovjaywang.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java笔记--静态工厂和Builder模式</title>
    <link href="http://ovjaywang.github.io/2016/04/13/effective%20java--%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82/"/>
    <id>http://ovjaywang.github.io/2016/04/13/effective java--静态工厂/</id>
    <published>2016-04-13T07:15:14.000Z</published>
    <updated>2016-05-19T17:13:19.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;静态工厂&quot;&gt;&lt;a href=&quot;#静态工厂&quot; class=&quot;headerlink&quot; title=&quot;静态工厂&quot;&gt;&lt;/a&gt;静态工厂&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static Boolean valueOf (boolean b){
        return b?Boolean.True:Boolean.False;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态工厂以其名字显见，以[类名.方法名]的方式调用，其静态函数主要返回其类的对象，一般是引用值。返回什么东西，由参数决定，这个工厂给你产出来。其在API开发中使用广泛。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;静态工厂最有趣的地方在于把方法&lt;strong&gt;提供者&lt;/strong&gt;同方法&lt;strong&gt;使用者&lt;/strong&gt;剥离开来，使用者不能明细地看到对象构造的具体过程，而是可见可得地获得所需的对象。当然好处有很多，例如返回的对象可以是该类的子类，能让被调用静态工厂方法的类不成为公有；例如有效的降低了构造对象的成本，静态工厂&lt;strong&gt;「&lt;/strong&gt;不生产对像，一般只是对象的搬运工&lt;strong&gt;」&lt;/strong&gt;。使用静态方法返回对象的方式在单态中使用广泛。&lt;/p&gt;
&lt;p&gt;List、Set有着相似的方式。它们都继承自Collection，同时不能实例化为该类的对象，必须通过子类实现父类的方法来实例化不同属性的对象。ArrayList HashSet等都通过注册的方式进行映射。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单态就是整个类能且只能有一个对象存在，为null则构造一个，不为null应返回该对象。例如购物车只能有一个、聊天平台只能有一个、饭馆的点菜平台只能有一个 这种类似的场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与不同参数的构造函数不同，不同参数的静态工厂可能返回同一属性的该(子)类的对象。该方式抛弃了重复冗杂的new形式，在C#常见newInstance()构造新对象，而在Java里就比较少的出现，一般都是左右对等的。&lt;/p&gt;
&lt;p&gt;最上面这段代码最有趣的地方在于，它是Boolean的包装类，输入的是值类型而返回的是Boolean对象,当然Boolean只实例化了两个对象。但当新的子类构建，简单的静态工厂必须重写，常用的改进方法有：&lt;/p&gt;
&lt;h2 id=&quot;反射机制-配置&quot;&gt;&lt;a href=&quot;#反射机制-配置&quot; class=&quot;headerlink&quot; title=&quot;反射机制+配置&quot;&gt;&lt;/a&gt;反射机制+配置&lt;/h2&gt;&lt;p&gt;  例如下面一段就是根据不同的类名，返回不同的对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static InterFace_Name staticFactory(String name)throws
                                InstantiationException,
                                IllegalAccessException,
                                ClassNotFoundException{     
        // 这边使用的是Java的Reflection机制来产生实例
        // 以后就算改变了这边的程式，客户端程式是不用更改的
        return (InterFace_Name) Class.forName(name).newInstance();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;注册方式-Service-Provider-Framework&quot;&gt;&lt;a href=&quot;#注册方式-Service-Provider-Framework&quot; class=&quot;headerlink&quot; title=&quot;注册方式(Service Provider Framework)&quot;&gt;&lt;/a&gt;注册方式(Service Provider Framework)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;注册方式需要&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务具体实现类(由服务提供商实现)&lt;/li&gt;
&lt;li&gt;服务提供者实现类，1为2的实例，(由服务提供商实现)&lt;/li&gt;
&lt;li&gt;服务定义接口，定义服务内容，不包含实现。&lt;/li&gt;
&lt;li&gt;服务提供者接口，3为4的实例，定义获取提供者的方式，不包含实现。&lt;/li&gt;
&lt;li&gt;服务提供者注册类&lt;br&gt;最常见的实例就是JDBC(Java DataBase Connection)。下面这段最常见的连接mysql的标准函数就很好的体现了注册的方式。&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; public synchronized static Connection getCon() 
     throws ClassNotFoundException, SQLException
 {
     //服务提供者接口
       String DRIVERNAME = &amp;quot;com.mysql.jdbc.Driver&amp;quot;;
       //java.sql.Driver.class这个是服务提供者接口，
       //服务提供者若使mysql，那就使用&amp;quot;com.mysql.jdbc.Driver&amp;quot;；
       //如果是sql server，那就使用&amp;quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&amp;quot;;
       //如果是Oracle，那就要用&amp;quot;oracle.jdbc.driver.OracleDriver&amp;quot;...
       String URL = &amp;quot;jdbc:mysql://URL/DataBase_Names&amp;quot;;
       String USER = &amp;quot;USER&amp;quot;;
       String PWD = &amp;quot;PWD&amp;quot;; 
       Connection connection = null;//接口 由服务提供者提供并实现具体服务 
       Class.forName(DRIVERNAME);
       //这里映射通过DriverManager判断获取的是哪个服务
       connection = (Connection) DriverManager.getConnection(URL, USER,PWD);
       //链接数据库  mysql已经在驱动管理注册了API(本机装mysql的时候)
       //这里使用者编写的服务访问getConnection这个API，
       if(connection!=null){return connection;}
       else{return null;}//具体的数据库操作逻辑   
 }
&lt;/code&gt;&lt;/pre&gt;
上式的意义就是，使用&lt;strong&gt;Java&lt;/strong&gt;连接上&lt;strong&gt;数据库&lt;/strong&gt;。注意，不是某种数据库，是数据库。数据库的提供商按照定义的接口（Java提供的,增删改查等数据库操作），都可以顺利的连接上它们的数据库。  &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Class.forName(&amp;quot;...&amp;quot;)&lt;/code&gt;这句实例化一个mysql等数据库提供商的&lt;font color=&quot;red&quot;&gt;服务提供者实现类&lt;/font&gt;，并将这个类的实例注册到DriverManager即&lt;font color=&quot;red&quot;&gt;服务提供者注册类&lt;/font&gt;。&lt;/li&gt;
&lt;li&gt;通过URL指明连接的地址和端口，判断所连接的数据库类别，在利用USERNAME PWD参数连接到数据库获取操作数据库的一个连接Connection。&lt;/li&gt;
&lt;li&gt;Connection作为一个实现类，客户端的程序得到了这个实例就可以操作各种数据库，但其内部的原理对客户端不可见的，这就是所谓的面向接口编程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里举一个炸裂的例子。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;具体服务接口定义了live和die，然后实现类实现了具体的方法&lt;/li&gt;
&lt;li&gt;服务提供者接口定义了获取服务实例的函数，然后服务提供者实现类实现了注册方式获取实例&lt;/li&gt;
&lt;li&gt;注册类则对ClassName和服务提供者接口进行绑定。相当于，对不同的服务提供商通过名字进行映射&lt;/li&gt;
&lt;li&gt;调用类则通过常规步骤，调用具体服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HaInterface.java&lt;br&gt;&lt;pre&gt;&lt;code&gt;package com.gua.com;
public interface HaInterface {
    public void Live();
    public void Die();
}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;HaClass.java&lt;br&gt;&lt;pre&gt;&lt;code&gt;package com.gua.com;
public class HaClass implements HaInterface{
    @Override
    public void Live() {
        System.out.println(&quot;给你们一些人生经验&quot;);
    }
    @Override
    public void Die() {
        System.out.println(&quot;又想搞大新闻!&quot;);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;Xuyimiao.java&lt;br&gt;&lt;pre&gt;&lt;code&gt;package com.gua.com;
public interface Xuyimiao {
    public HaInterface HahaGo();
}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;WoyaoXuyimiao.java&lt;br&gt;&lt;pre&gt;&lt;code&gt;package com.gua.com;
public class WoyaoXuyimiao implements  Xuyimiao{
    static{
        MingwangManager.registerProvider(&quot;辣妹子辣&quot;, new WoyaoXuyimiao());  
    }
    @Override
    public HaInterface HahaGo() {
        return new HaClass(); 
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;MingwangManager.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.gua.com;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class MingwangManager {
    public MingwangManager(){};
    private static final Map&amp;lt;String, Xuyimiao&amp;gt; providers = new ConcurrentHashMap&amp;lt;String, Xuyimiao&amp;gt;();  
    public static void registerProvider(String name, Xuyimiao p) {
            providers.put(name, p);  
        }  
    public static HaInterface getService(String name) {       
            Xuyimiao p = providers.get(name);  
            if (p == null) {  
                throw new IllegalArgumentException(  
                        &amp;quot;No provider registered with name:&amp;quot; + name);  
            } 
            return p.HahaGo();
        }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;TestHa.java&lt;br&gt;&lt;pre&gt;&lt;code&gt;package com.gua.com; 
public class TestHa {  
    public static void main(String[] args) throws ClassNotFoundException {
        Class.forName(&quot;com.gua.com.WoyaoXuyimiao&quot;);  
        HaInterface hi = MingwangManager.getService(&quot;辣妹子辣&quot;);  
        hi.Live();  
        hi.Die();  
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2 id=&quot;这种方式已经不推荐-工厂模式&quot;&gt;&lt;a href=&quot;#这种方式已经不推荐-工厂模式&quot; class=&quot;headerlink&quot; title=&quot;这种方式已经不推荐-工厂模式&quot;&gt;&lt;/a&gt;这种方式已经不推荐-工厂模式&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;工厂方法&lt;/a&gt;  &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;抽象工厂&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考文章:&lt;a href=&quot;(http://liwenshui322.iteye.com/blog/1267202)&quot;&gt;JAVA 服务提供者框架介绍&lt;/a&gt;、&lt;a href=&quot;(http://blog.csdn.net/csdn0123/article/details/7388445)&quot;&gt;构造器和静态方法&lt;/a&gt;&lt;/p&gt;
&lt;script src=&quot;../../../../js/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;link href=&quot;../../../../css/monokai_sublime.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;静态工厂&quot;&gt;&lt;a href=&quot;#静态工厂&quot; class=&quot;headerlink&quot; title=&quot;静态工厂&quot;&gt;&lt;/a&gt;静态工厂&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public static Boolean valueOf (boolean b){
        return b?Boolean.True:Boolean.False;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态工厂以其名字显见，以[类名.方法名]的方式调用，其静态函数主要返回其类的对象，一般是引用值。返回什么东西，由参数决定，这个工厂给你产出来。其在API开发中使用广泛。&lt;br&gt;
    
    </summary>
    
      <category term="代码狗" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="test" scheme="http://ovjaywang.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hexo双备份Github和Coding及域名绑定</title>
    <link href="http://ovjaywang.github.io/2016/04/10/Hello-Hexo/"/>
    <id>http://ovjaywang.github.io/2016/04/10/Hello-Hexo/</id>
    <published>2016-04-10T14:51:49.000Z</published>
    <updated>2017-01-17T16:44:28.000Z</updated>
    
    <content type="html">&lt;p&gt;感谢&lt;a href=&quot;http://zipperary.com/2013/05/28/hexo-guide-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个教程&lt;/a&gt;&lt;br&gt;还有&lt;a href=&quot;http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个&lt;/a&gt;&lt;br&gt;解决了好多bugs的&lt;a href=&quot;http://www.jianshu.com/p/35e197cb1273&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个&lt;/a&gt;&lt;br&gt;优化cdn图床缓冲的&lt;a href=&quot;http://lukang.me/2015/optimization-of-hexo-2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.dute.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个&lt;/a&gt;让我找到了便宜的狗爹优惠码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;从一开始的阵地wp搬到这里来了。后会有期了dooby.me 再见了WordPress  
默默的是有些不舍。虽然push很慢虽然被墙了大半  
4年光阴不复返啊。从一个逗比成长为大逗比了。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;hexo坑还是挺多的。&lt;br&gt;$$ \begin{bmatrix} x \\\ y \\\ 1&lt;br&gt;\end{bmatrix} \sim \begin{bmatrix} f &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\ 0 &amp;amp; f &amp;amp; 0 &amp;amp; 0 \\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \end{bmatrix} \begin{bmatrix} r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\\ r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\\ r_{31} &amp;amp; r_{32}&amp;amp; r_{33} &amp;amp; t_z \\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{bmatrix} \begin{bmatrix} p \\\ q \\\ 0 \\\ 1 \end{bmatrix} \sim \begin{bmatrix} fr_11 &amp;amp; fr_12 &amp;amp; ft_x \\\ fr_21 &amp;amp; fr_22 &amp;amp; ft_y \\\ r_{31} &amp;amp; r_32 &amp;amp; t_z \end{bmatrix} \begin{bmatrix} p \\\ q \\\ 1 \end{bmatrix}&lt;br&gt;$$$$\sim \begin{bmatrix} h_11 &amp;amp; h_12&amp;amp;h_13 \\\ h_21 &amp;amp; h_22 &amp;amp; h_23 \\\ h_31 &amp;amp; h_32 &amp;amp; h_33 \end{bmatrix} \begin{bmatrix} p \\\ q \\\ 1 \end{bmatrix}$$&lt;/p&gt;
&lt;p&gt;$$\begin{pmatrix}&lt;br&gt;     1 &amp;amp; a_1 &amp;amp; a_1^2 &amp;amp; \cdots &amp;amp; a_1^n \\\\&lt;br&gt;     1 &amp;amp; a_2 &amp;amp; a_2^2 &amp;amp; \cdots &amp;amp; a_2^n \\\\&lt;br&gt;     \vdots  &amp;amp; \vdots&amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\\\&lt;br&gt;     1 &amp;amp; a_m &amp;amp; a_m^2 &amp;amp; \cdots &amp;amp; a_m^n&lt;br&gt;\end{pmatrix}$$&lt;/p&gt;
&lt;p&gt;$$f(x,y)=\left\\{\begin{matrix}&lt;br&gt;\frac{4}{m}&amp;amp; 0&amp;lt;x&amp;lt;\frac{a}{2},0&amp;lt;y&amp;lt;\frac{\pi }{2} \\\\&lt;br&gt;0 &amp;amp; Others&lt;br&gt;\end{matrix}\right.$$&lt;/p&gt;
&lt;h1 id=&quot;公式和Markdown冲突&quot;&gt;&lt;a href=&quot;#公式和Markdown冲突&quot; class=&quot;headerlink&quot; title=&quot;公式和Markdown冲突&quot;&gt;&lt;/a&gt;公式和Markdown冲突&lt;/h1&gt;&lt;p&gt;由于下划线在LaTex公式编辑器和MarkDown中都有，因此如果在公式中有两个xiahuaxian”_”则必须注意不要发生冲突，需加入反斜杠在下划线前！！在SublimeText中也可以看到如果又两个双下划线字体已变成斜体。&lt;br&gt;$$ 2H_2 = 2O_2+H_2$$&lt;/p&gt;
&lt;h1 id=&quot;括号随比例显示不出&quot;&gt;&lt;a href=&quot;#括号随比例显示不出&quot; class=&quot;headerlink&quot; title=&quot;括号随比例显示不出&quot;&gt;&lt;/a&gt;括号随比例显示不出&lt;/h1&gt;&lt;p&gt;呵呵哒，无解。只能用小的。切记不能用\left \right将左右公式包含进来&lt;/p&gt;
&lt;h1 id=&quot;WordPress迁移&quot;&gt;&lt;a href=&quot;#WordPress迁移&quot; class=&quot;headerlink&quot; title=&quot;WordPress迁移&quot;&gt;&lt;/a&gt;WordPress迁移&lt;/h1&gt;&lt;p&gt;这个使用hexo-migrate-wordpress插件还不错 但是切记导出的xml是文章 tag和category会自动建好。否则使用hexo migrate wordpress 会报错&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;沙扬娜拉dooby.me&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/05/02/5727757865698.png&quot; alt=&quot;dooby.me&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Github和Coding双备份&quot;&gt;&lt;a href=&quot;#Github和Coding双备份&quot; class=&quot;headerlink&quot; title=&quot;Github和Coding双备份&quot;&gt;&lt;/a&gt;Github和Coding双备份&lt;/h1&gt;&lt;p&gt;按照一般的教程都能配置好Github的。但是Coding对国内线路速度相对较快（好蛋疼GitCafe已经被收了）配置文档差不多是这样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;deploy:
   type: git
   repo: 
      github: https://github.com/{YOUR_ID}/{YOUR_ID}.github.io.git,master
      coding: https://git.coding.net/{YOUR_ID}/{BLOG　NAME}.git,master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然也需要先将ssh的key添加上去（同一个码即可），Coding不需要同一个名字..然而最近发现Coding的项目展示页面收费了……虽说是注重团队协作和代码交易 但是个人用户的托管真的完全要丢掉了吗？差不多1块钱1天的样子 相当不划算&lt;/p&gt;
&lt;h1 id=&quot;SEO是极好的&quot;&gt;&lt;a href=&quot;#SEO是极好的&quot; class=&quot;headerlink&quot; title=&quot;SEO是极好的&quot;&gt;&lt;/a&gt;SEO是极好的&lt;/h1&gt;&lt;p&gt;切莫贪杯 google就好 但是 切记！标题不要带有‘&amp;amp;’。年少无知，这个符号不能正常解析出xml会报错&lt;/p&gt;
&lt;h1 id=&quot;域名绑定&quot;&gt;&lt;a href=&quot;#域名绑定&quot; class=&quot;headerlink&quot; title=&quot;域名绑定&quot;&gt;&lt;/a&gt;域名绑定&lt;/h1&gt;&lt;p&gt;切记@解析的是{YOUR_ID}.github.io的地址而不是github.com的 CNAME需要放在source下才能被generate。dnspod被企鹅注资后ui变得相当土了&lt;/p&gt;
&lt;h1 id=&quot;专注写作&quot;&gt;&lt;a href=&quot;#专注写作&quot; class=&quot;headerlink&quot; title=&quot;专注写作&quot;&gt;&lt;/a&gt;专注写作&lt;/h1&gt;&lt;p&gt;放弃各种挂饰 插件 统计吧 seo和评论就足够了。多写作多讨论 当然很想适时的学一发nodejs因为折腾了好久ig的照片还是没能get进来。&lt;/p&gt;
&lt;h1 id=&quot;Latex公式&quot;&gt;&lt;a href=&quot;#Latex公式&quot; class=&quot;headerlink&quot; title=&quot;Latex公式&quot;&gt;&lt;/a&gt;Latex公式&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/emptyset110/article/details/50123231&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Latex公式与Marked.js共存&lt;/a&gt;，否则，需要转义编写个别字符&lt;br&gt;&lt;script src=&quot;//gist.github.com/86cc40065a691b7c4534e483249583dd.js?file=transValue.java&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;NEW: DevDocs now comes with syntax highlighting. &lt;a href=&quot;http://devdocs.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://devdocs.io&lt;/a&gt;&lt;/p&gt;&lt;footer&gt;&lt;strong&gt;@DevDocs&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://twitter.com/devdocs/status/356095192085962752&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;twitter.com/devdocs/status/356095192085962752&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&lt;/p&gt;&lt;footer&gt;&lt;strong&gt;David Levithan&lt;/strong&gt;&lt;cite&gt;Wide Awake&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Every interaction is both precious and an opportunity to delight.&lt;/p&gt;&lt;footer&gt;&lt;strong&gt;Seth Godin&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Welcome to Island Marketing&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;void transValue(int a,int b){
        a ^= b;
        b ^= a;
        a ^=b;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;alert(&#39;Hello World!&#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class=&quot;pullquote [class]&quot;&gt;&lt;p&gt;blah blah blah&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;2016.04.11&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;感谢&lt;a href=&quot;http://zipperary.com/2013/05/28/hexo-guide-2/&quot;&gt;这个教程&lt;/a&gt;&lt;br&gt;还有&lt;a href=&quot;http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool&quot;&gt;这个&lt;/a&gt;&lt;br&gt;解决了好多bugs的&lt;a href=&quot;http://www.jianshu.com/p/35e197cb1273&quot;&gt;这个&lt;/a&gt;&lt;br&gt;优化cdn图床缓冲的&lt;a href=&quot;http://lukang.me/2015/optimization-of-hexo-2.html&quot;&gt;这个&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.dute.me/&quot;&gt;这个&lt;/a&gt;让我找到了便宜的狗爹优惠码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;从一开始的阵地wp搬到这里来了。后会有期了dooby.me 再见了WordPress  
默默的是有些不舍。虽然push很慢虽然被墙了大半  
4年光阴不复返啊。从一个逗比成长为大逗比了。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="槽" scheme="http://ovjaywang.github.io/categories/%E6%A7%BD/"/>
    
    
      <category term="hello" scheme="http://ovjaywang.github.io/tags/hello/"/>
    
  </entry>
  
  <entry>
    <title>记静态Ip的坑</title>
    <link href="http://ovjaywang.github.io/2016/04/01/%E8%AE%B0%E9%9D%99%E6%80%81ip%E7%9A%84%E5%9D%91/"/>
    <id>http://ovjaywang.github.io/2016/04/01/记静态ip的坑/</id>
    <published>2016-04-01T08:06:32.000Z</published>
    <updated>2016-04-28T16:36:57.000Z</updated>
    
    <content type="html">&lt;p&gt;明明在hadoop配置静态IP的时候被坑过一次，却完全想不起来怎么解决的。尤其是在ssh登录的时候需要记下host和ip的对应，才能直接输出主机名来访问局域网内的其他主机。&lt;br&gt;现在记下来。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1.原生linux+无线网卡/有线端口&lt;br&gt;ubuntu改interface和fedora改eth0-XXXXX都是极好的 里面对应的netmask ipaddress gateway dns1dns2（dnsnameserver）在resolv.conf配置dns信息&lt;br&gt;但是&lt;strong&gt;比较easy&lt;/strong&gt;的纯粹做法直接在有线/无线的连接信息里面加这几个对应信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/04/01/56fe2742cea08.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最最最easy的就是直接在路由器dhcp绑定mac静态分配，直接原生效果拔群。&lt;/p&gt;
&lt;p&gt;2.虚拟机+有线端口/原生无线网卡&lt;/p&gt;
&lt;p&gt;这种情况有点坑 虚拟机切记开启桥接模式 直接把主机和虚拟机按照局域网内的两台机器分配ip。这样当然也可以按照配置文件配置 切记写入MN_COTROLLED=yes 然后开启networkmanager管理网络，并使用&lt;/p&gt;
&lt;pre class=&quot;brush: shell; gutter: true&quot;&gt;systemctl enable netwoekmanager&lt;/pre&gt;

&lt;p&gt;开启开机启动。诚然，在连接信息直接配置也行。&lt;br&gt;3.虚拟机+外接无线网卡&lt;br&gt;呵呵 没找到解决方案。直接桥接驱动没法搞；直接nat不是我想要的结果。反正奏事上不了网ping不了局域网&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;明明在hadoop配置静态IP的时候被坑过一次，却完全想不起来怎么解决的。尤其是在ssh登录的时候需要记下host和ip的对应，才能直接输出主机名来访问局域网内的其他主机。&lt;br&gt;现在记下来。&lt;/p&gt;
    
    </summary>
    
      <category term="什么都学一下" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="hadoop" scheme="http://ovjaywang.github.io/tags/hadoop/"/>
    
      <category term="静态ip" scheme="http://ovjaywang.github.io/tags/%E9%9D%99%E6%80%81ip/"/>
    
  </entry>
  
  <entry>
    <title>最近Demo 模块 算法总结</title>
    <link href="http://ovjaywang.github.io/2016/03/08/demo-conclusion/"/>
    <id>http://ovjaywang.github.io/2016/03/08/demo-conclusion/</id>
    <published>2016-03-08T09:43:56.000Z</published>
    <updated>2016-08-30T13:32:36.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://ju.outofmemory.cn/entry/106397&quot; title=&quot;http://ju.outofmemory.cn/entry/106397&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ju.outofmemory.cn/entry/106397&lt;/a&gt; 【坑妹填完】&lt;/p&gt;
&lt;p&gt;最近各种乱整。。文章妹时间管光顾着折腾手头派下来的事情了。再加上每天固定的复习提高一下。小论文完全没有头绪。&lt;br&gt;最近get到的实用方法还是很多阿。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;DBScan（Density-Based-Spatial-Clustering-of-Applications-with-Noise）基于密度的含噪空间聚类&quot;&gt;&lt;a href=&quot;#DBScan（Density-Based-Spatial-Clustering-of-Applications-with-Noise）基于密度的含噪空间聚类&quot; class=&quot;headerlink&quot; title=&quot;DBScan（Density-Based Spatial Clustering of Applications with Noise）基于密度的含噪空间聚类&quot;&gt;&lt;/a&gt;&lt;strong&gt;DBScan&lt;/strong&gt;（Density-Based Spatial Clustering of Applications with Noise）&lt;strong&gt;基于密度的含噪空间聚类&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;最大特点是：多维、任何形状聚类、聚类数任意、噪声可控、对输入不敏感；缺点很明显，需要提前知道2个参数（一般实验多了，根据经验对同一类型聚类可以不用改。），时间复杂度和空间复杂度都很大，需要计算点两两之间距离[这里需要优化，否则算法超出一般忍受时间] 不对密度变化做出选择。&lt;br&gt;输入参数2个，单一点半径范围R及其最小包含的点数N。算法本质是遍历所有点并计算邻域内的点数并拓展该类（以R范围内是否达到N来判断）。被分类的点将会标记并不再被检测到。因此耗时表现在邻域查找和拓展聚类上。但解算效果相当良好。&lt;br&gt;算法的优化方案相当多：kdtree的、基于网格计算的、基于适应性解算阈值的、局部敏感哈希。主要解决的都是如何加快求解邻域解求速度。诚然它的算法复杂度有n^3显然想要加快并不是那么容易。深入研讨了一番发现计算距离时有的不止一遍，因此写入硬盘或许是个好的方案，但是I/O读取的效率就要考虑进来了；还有一种方式是限制深入迭代次数，即做多在第几层nearestpoint()这个数组中进行聚类的拓展。这种做法的危害是使得同一个点集很可能多次才并入，或者完全没有并到一块，因此需要一个后手，将聚类中心相近的再次组合，其实在kdtree中也有类似的做法。参考&lt;a href=&quot;https://github.com/alitouka/spark_dbscan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;基于SPark的DBSCAN的图解&lt;/a&gt;，KDTree建立时，按区域分割好数据后，同一类的点集亦可能先分散于个个区间。各自区间先进行小聚类后，再进行大聚类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/03/30/56fb7e092b350.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（中了SPark的毒，后面会进行测试）&lt;br&gt;demo很好的展示了算法的原理。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.naftaliharris.com/blog/visualizing-dbscan-clustering/&quot; title=&quot;http://www.naftaliharris.com/blog/visualizing-dbscan-clustering/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.naftaliharris.com/blog/visualizing-dbscan-clustering/&lt;/a&gt; 在线666可视化理解dbscan过程。不同的实例可以看到，对不同图形的检测相当准确；同时聚类精度亦相当高。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/6621630/dbscan-code-in-c-sharp-or-vb-net-for-cluster-analysis&quot; title=&quot;http://stackoverflow.com/questions/6621630/dbscan-code-in-c-sharp-or-vb-net-for-cluster-analysis&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/6621630/dbscan-code-in-c-sharp-or-vb-net-for-cluster-analysis&lt;/a&gt;stackoverflow图解dbscan&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yzuzun.com/2015/07/dbscan-clustering-algorithm-and-c-implementation/&quot; title=&quot;https://www.yzuzun.com/2015/07/dbscan-clustering-algorithm-and-c-implementation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.yzuzun.com/2015/07/dbscan-clustering-algorithm-and-c-implementation/&lt;/a&gt; dbscan的C#实现和作者的gayhub项目&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://download.csdn.net/detail/f112122/7482303&quot; title=&quot;http://download.csdn.net/detail/f112122/7482303&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://download.csdn.net/detail/f112122/7482303 &lt;/a&gt;c#简易可视化工程例子&lt;/p&gt;
&lt;p&gt;诚然，boost把很多常用的算法都写进去了。但c++使用起来才比较顺。这是c++环境下使用dbscan的正确方式：上boost。比如下面这个&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yusufuzun/dbscan&quot; title=&quot;https://github.com/yusufuzun/dbscan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yusufuzun/dbscan&lt;/a&gt;（C# 以算法原理为基准 不是很快）&lt;/p&gt;
&lt;p&gt;或这个&lt;a href=&quot;https://github.com/Terranlee/DBSCAN&quot; title=&quot;https://github.com/Terranlee/DBSCAN&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Terranlee/DBSCAN&lt;/a&gt;（C++&amp;amp;boost&amp;amp;KDTree&amp;nbsp; 至今没有明白第一个参数ire的含义啊。一般都2个参数就好了啊 而且结果貌似也不太对 等待修正）&lt;/p&gt;
&lt;h1 id=&quot;boost的使用&quot;&gt;&lt;a href=&quot;#boost的使用&quot; class=&quot;headerlink&quot; title=&quot;boost的使用&quot;&gt;&lt;/a&gt;&lt;strong&gt;boost的使用&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;上边两个github的例子都基于c++开发，其中都使用到了流行的c++高性能计算类库boost。&lt;/p&gt;
&lt;p&gt;linux下的编译和安装遵循这个帖比较顺 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ju.outofmemory.cn/entry/106397&quot; title=&quot;http://ju.outofmemory.cn/entry/106397&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ju.outofmemory.cn/entry/106397&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;KDTree &lt;/p&gt;
&lt;p&gt;KDTree作为一种数据结构的拓展，其实是一种变异的二叉排序树，其最最最原始的构造就是，在二叉树左小右大的基础上，对多维数据，第一层比较第一个维度，第二层比较第二个维度，以此类推…………排到最后一维又返回第一位继续排，当然，而已设定排序的次数，到多少维就懒得排了。这个数据结构的好处是，寻找欧几里得空间（也就是任意维度的两个对象的连线长度&amp;amp;有的地方也使用该值当做两个对象相似度）的最邻近点（集）复杂度大大降低，不用迭代整个数就能找到最近的点。&lt;/p&gt;
&lt;p&gt;上面说的DBSCAN、后面的ICP、图像匹配中的SIFT算子比较相似度（128维），使用KDTree可以很好的解决时间太长的问题。&lt;/p&gt;
&lt;p&gt;来一波树形结合，&lt;/p&gt;
&lt;p&gt;KDTree的改进方法有Best Bin Fisrt、Best First Search。它主要的临近查找是基于路径和回路的，但没有考虑节点的一些性质，BBF则根据查询路径上的节点进行排序，排序原则是按照超平面的最短距离。另外还可设置超时，优先级队列中的所有节点都经过检查或者超出时间限制时，返回当前最好结果当做近似的最近邻。这种方式在高维上效率提升很大。（尤其sift）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;font color=&quot;#555555&quot;&gt;&lt;/font&gt;&amp;nbsp;&lt;/p&gt;
&lt;h1 id=&quot;ICP（Iterative-closest-point）&quot;&gt;&lt;a href=&quot;#ICP（Iterative-closest-point）&quot; class=&quot;headerlink&quot; title=&quot;ICP（Iterative closest point）&quot;&gt;&lt;/a&gt;&lt;strong&gt;ICP&lt;/strong&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Iterative_closest_point&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Iterative closest point&lt;/a&gt;）&lt;/h1&gt;&lt;p&gt;点集匹配算法——两组有部分重叠区域的点集，进行拟合和对应点匹配。匹配中如果模式重复程度过高可能陷入局部最小值，因此需要对模式进行了良好的解析。&lt;/p&gt;
&lt;p&gt;算法原理：①算法先解算归一两组点集比例尺、解算质心，将质心重合②对其中一个点集，寻找每个另一点集的最近点，解算梯度和旋转平移量③再次计算最近点，若旋转量小于阈值则停止，若大于阈值则继续②步骤。④按照对应点计算H矩阵（单映矩阵）。&lt;/p&gt;
&lt;p&gt;第二部中的关键步骤其实就是解算每一步的迭代旋转和平移量，用到的是最小二乘法；其次，输入模式及输入顺序对匹配影像也比较大。一般的，停止迭代可以设置限差或者迭代次数。&lt;/p&gt;
&lt;p&gt;VTK5.8的C#dll中有包含ICP最新的算法，但算法较旧，效率较低，但新版6.0+在C#上未开源，忧伤。算法中，求取最近点有三种做法，一点对点，直接找最近点，常用kd-tree实现；二点对面，求取最近的切面的一个切点，主要针对点集和曲面匹配；三点做发现与另一曲面交点，主要针对面与面配准。&lt;/p&gt;
&lt;p&gt;mrpt类库中关于ICP的例子&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mrpt.org/Iterative_Closest_Point_%28ICP%29_and_other_matching_algorithms&quot; title=&quot;http://www.mrpt.org/Iterative_Closest_Point_%28ICP%29_and_other_matching_algorithms&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mrpt.org/Iterative_Closest_Point_%28ICP%29_and_other_matching_algorithms&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;结合NUnit的ICP算法&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.codeproject.com/Articles/865830/Point-cloud-alignment-ICP-methods-compared&quot; title=&quot;http://www.codeproject.com/Articles/865830/Point-cloud-alignment-ICP-methods-compared&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.codeproject.com/Articles/865830/Point-cloud-alignment-ICP-methods-compared&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;适应性：对自由形状的曲面适应性较好，VTK算法在LiDar数据扫描配准中应用较好。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;convex-hull-of-a-set-of-points-点集的凸包&quot;&gt;&lt;a href=&quot;#convex-hull-of-a-set-of-points-点集的凸包&quot; class=&quot;headerlink&quot; title=&quot;convex hull of a set of points 点集的凸包&quot;&gt;&lt;/a&gt;&lt;strong&gt;convex hull of a set of points&lt;/strong&gt; 点集的凸包&lt;/h1&gt;&lt;p&gt;没啥特点。但相当基础。在外接圆计算、外接矩形计算的时候必须首先解算。demo相当完美。可直接改了用了。能把demo做的这么直白这么易用相当666了(c#)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://csharphelper.com/blog/2014/07/find-the-convex-hull-of-a-set-of-points-in-c/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;查找点集外包圆&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;minimal bounding rectangle for a polygon &lt;/strong&gt;凸包的最小外接矩形。这个算法在解求聚类、数据形态方面有很多利用。前提是前面提到的点集凸包以及点集是否按顺时针排序。同样的网站，给的demo我只能说酷炸了。（c#）包含了两种模式：最小面积和最小周长，两者相差不会很大。demo的计算原则是面积。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://csharphelper.com/blog/2014/07/find-minimal-bounding-rectangle-polygon-c/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算凸多边形最小外接矩形&lt;/a&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://ju.outofmemory.cn/entry/106397&quot; title=&quot;http://ju.outofmemory.cn/entry/106397&quot;&gt;http://ju.outofmemory.cn/entry/106397&lt;/a&gt; 【坑妹填完】&lt;/p&gt;
&lt;p&gt;最近各种乱整。。文章妹时间管光顾着折腾手头派下来的事情了。再加上每天固定的复习提高一下。小论文完全没有头绪。&lt;br&gt;最近get到的实用方法还是很多阿。&lt;br&gt;
    
    </summary>
    
      <category term="代码狗" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%A3%E7%A0%81%E7%8B%97/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="dbscan" scheme="http://ovjaywang.github.io/tags/dbscan/"/>
    
      <category term="demo" scheme="http://ovjaywang.github.io/tags/demo/"/>
    
      <category term="ICP" scheme="http://ovjaywang.github.io/tags/ICP/"/>
    
      <category term="MMC" scheme="http://ovjaywang.github.io/tags/MMC/"/>
    
      <category term="MME" scheme="http://ovjaywang.github.io/tags/MME/"/>
    
      <category term="SPark" scheme="http://ovjaywang.github.io/tags/SPark/"/>
    
      <category term="算法" scheme="http://ovjaywang.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>由opencv中findFundamentalMat和findHomography区别的引申</title>
    <link href="http://ovjaywang.github.io/2016/01/25/opencv-findhomography-findfundanmentalmat/"/>
    <id>http://ovjaywang.github.io/2016/01/25/opencv-findhomography-findfundanmentalmat/</id>
    <published>2016-01-24T16:54:26.000Z</published>
    <updated>2017-01-17T16:44:28.000Z</updated>
    
    <content type="html">&lt;p&gt;openCV中有两个函数，findhomography和findfundamentalmat，长的很像。。一开始严重的弄混，以为都是求对应点投影矩阵的公式，万万没想到其实是两个完全不同的内涵。😒&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;opencv 中，进行&lt;strong&gt;图像拼接(全景拼接 航摄拼接 三维重建 街景地图)&lt;/strong&gt;，大致流程如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用opencv提供的各类型特征点检测方法（Fast Start SIFT SURF ORB SimpleBlobPyramidAdapter DynamicAdapter 等）在图像中将感兴趣的有独特标识的点找出来,其中orb 是最近提出效率较高的检测和描述算法，金字塔算法则是更高的提高效率的算法；&lt;/li&gt;
&lt;li&gt;利用不同的描述方式（SIFT SURF），对特征点的信息（周围的梯度、灰度相关性 二进制编码等）进行描述； &lt;/li&gt;
&lt;li&gt;利用不同原则的匹配方式（BF Flann-based等），对这些描述子（一般是多维矩阵）进行匹配（匹配中数据的输入参数的筛选Ransac方法），对匹配结果反向计算进一步的筛查，选择更健壮更有代表性的数据（knn Ransac），&lt;/li&gt;
&lt;li&gt;最后利用findhomography找到映射矩阵，再利用affine将该坐标映射关系对其中一幅图贴到其中一幅图中。 完成拼接。拼接区域涉及融合平滑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这其中，&lt;strong&gt;findfundamentalmat()&lt;/strong&gt;和&lt;strong&gt;findhomography()&lt;/strong&gt;都是用来查找两组匹配坐标点的映射关系的（两组坐标几何 数目相同 同一&lt;strong&gt;数组位&lt;/strong&gt;为同一对匹配点）试着运行了一下homography生成的矩阵拼接效果良好。而findfundamentalmat就不太6.找了一些相关资料，其实这是两个相似但不相同的函数。so开始之前科普几个概念：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;核点（极点）&lt;/strong&gt;：摄影中心连线（基线）ss’延长线，与左右影像的交点，分为左右核点（极点）。（注：下图两影像接近平行，则ss’连线与影像无交点，而在下下图中，el er分别为左右核点【极点】）亦可理解为左右摄影中心分别在对方像片的像点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核面（极面）&lt;/strong&gt; ：过摄影基线与物方任意一点组成的平面。（所以缩，物方点不同，核面一般也不同 任意一个下图的PO1O2都是核面）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核线（极线）：立体像对中，同名光线与摄影基线所组成核面与左右像片的交线。&lt;/strong&gt; （不同同名点极线不同，因而有很多很多条） &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;极线约束&lt;/strong&gt; ：同一个点在两幅图像上的映射，已知左图映射点p1，那么右图映射点p2一定在p1的外极线上，这样可以减少匹配点数量。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce7786da1fa.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;上图中，红线即为极线，物方点P（X,Y,Z）分别在左右两图留下了同名点（xl，yl）、（xr,yr）。Tx即为基线长。但上图为两个平面接近平行且z方向接近0，但一般情况下，两像平面以任意角度成像同时内参数并不相同，因此上图中的极线呈现出共线的情况，更多的情况是下面这个图，两图像成任意角度。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce782a3235f.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;下图中，O1O2连线与左右像平面交点el和er即为左右极点(极点亦可理解为左右摄影中心在另一像平面的像)，而极线则为plel和prer。可以看到，这两条线显然就不平行了。 &lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce77b362343.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;基线&lt;/strong&gt; ：相邻两摄站点（摄影中心 一般标为s）之间的连线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主核面&lt;/strong&gt; ：左右像主点分别与基线构成的平面，分别称为左主核面和右主核面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;灭点vanishing &lt;/strong&gt; point：平行线在二维图像中汇聚的地方，空间中每一组平行线都有自己的灭点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;灭线vanishing line（消隐线 ）&lt;/strong&gt; ：不同的灭线连线，即灭线。如果两组不同的平行线，都平行于大地，则他们的连线就是地平线（horizon line）&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;第一个矩阵Essential本质矩阵&quot;&gt;&lt;a href=&quot;#第一个矩阵Essential本质矩阵&quot; class=&quot;headerlink&quot; title=&quot;第一个矩阵Essential本质矩阵&quot;&gt;&lt;/a&gt;第一个矩阵Essential本质矩阵&lt;/h1&gt;&lt;p&gt;由于拍摄物体时，摄影中心并不能被反映在图像中。如果让第二个观察者同时拍摄下某摄影中心和它所拍的照片呢?&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cfbd34f3c9e.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;反映在第二个观察者的照片，摄影中心和物体分别投影在像片上，任意第一个摄影中心和它所拍摄物体的连线都可视为第二个摄影中心的极线。直观的理解，即为下图的erpr。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cfc06a0ddc5.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;极线约束的理论就是左侧的物体成像在右侧的同名点一定在erpr上。&lt;/strong&gt;反映左右极线关系的就是表达向量和右向量之间的约束关系的——&lt;strong&gt;本质矩阵&lt;/strong&gt;即&lt;strong&gt;Eseential Matrix&lt;/strong&gt;。但大多数情况下，别的摄影中心并不一定会被成像，即极点不在相片中。如下图&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cfc2d883aab.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;具体的矩阵运算参考 &lt;a href=&quot;http://www.cnblogs.com/gemstone/archive/2011/12/20/2294551.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;计算机视觉基础4——对极几何(Epipolar Geometry)&lt;/strong&gt;&lt;/a&gt; ，原理为&lt;strong&gt;三线同面&lt;/strong&gt;（下图蓝色区域三边）  &lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce77dc874bc.png&quot; alt=&quot;&quot;&gt; &lt;/center&gt;

&lt;p&gt;&lt;strong&gt;其中，E是本质矩阵（Essential Matrix），R是像平面旋转矩阵，T是摄影中心平移矩阵，Pl和Pr分别为左右摄影中心指向同名点P的向量。S由矩阵T决定，具体形式为&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce77fc78812.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;本质矩阵&lt;/strong&gt; 采用的是相机的&lt;strong&gt;外部参数&lt;/strong&gt;，也就是说采用相机坐标(The essential matrix uses CAMERA coordinates)，不涉及相机内参数，如果要分析数字图像，则要考虑坐标(u,v)，此时需要用到内部参数(To use image coordinates we must consider the INTRINSIC camera parameters)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 谨记1：Essential Matrix是连结两个摄影中心指向同名点的向量的矩阵，秩为2。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 左向量·E·右向量=0！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; E由两部分组成！E=R·S  E仅由外方位元素决定！一张图记住E!!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cfcab0b492e.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上式Pr Pl均基于物方三维坐标。同理由向量引申而出的，则是同名点的像素坐标，原理是&lt;strong&gt;共线方程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二维同名点&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d00bc787259.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;上图中推导出对极几何中相当重要的公式，E矩阵作为连接同名点像素坐标而出现，这就意味着，已知求取E的外方位参数，就能求取出左右同名点的对应关系。然而，其中隐含的条件是在共线方程的化简中，默认忽略了镜头畸变。然而这已足够重要，在镜头畸变在拼接中影响不大时，该公式在仅仅知道外方位元素的情况就能解算corresponding point&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;极线方程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同理，由于极点、同名点都位于极线上，因此亦可通过E求得极线的方程（采用相机坐标系）。&lt;/p&gt;
&lt;p&gt;设极线方程为 au + bv + c = 0&lt;/p&gt;
&lt;p&gt;使用齐次坐标，矩阵表示为：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d01aa83d7d6.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;其中，$\widetilde{p}$是像片任意同名点相机坐标，$\widetilde{l}$是方程系数。又依据同名点公式，$$Ep_{l} =\widetilde{l_{r}}$$，所以！对应外极线的方程系数可以直接由E矩阵和本侧同名点求出。其中，$\widetilde{l_{l}}$是左极点对应外极线方程。&lt;/p&gt;
&lt;p&gt;当已知左侧点，其右侧对应点在直线&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d08c864e4a7.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;当已知右侧点，其左侧对应点在极线&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d01c07d68ed.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;strong&gt;极点&lt;/strong&gt;&lt;br&gt;&lt;br&gt;别忘了。极点也是在极线上，所以有&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d0673df0710.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;且，极点属于所有极线，因而&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d0678f1ddfc.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;上式可用来定位极点的坐标&lt;br&gt;&lt;br&gt;&lt;em&gt; &lt;/em&gt; &lt;em&gt;&lt;br&gt;&lt;br&gt;# &lt;strong&gt; 第2个矩阵 Fundamental基础矩阵&lt;/strong&gt;&lt;br&gt;&lt;br&gt;另一个需要提到的概念是基础矩阵。&lt;br&gt;&lt;br&gt;Essential矩阵使用CameraCoords相机坐标系。尽管其中可计算像素坐标，但仍然以摄影中心为原点，像平面所有点z值都是f。当考虑相机内参数时，这就是FundamentalMatrix基础矩阵&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/22/56a2556c54d1d.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;该图显示了fundamentalmatrix（基础矩阵）的基本内涵。p q分别为同名点。计算基础矩阵需要考虑到内参数的&lt;strong&gt;仿射变换&lt;/strong&gt;。M为内参数的矩阵，包含6个参数的3&lt;/em&gt;3矩阵。&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d069db39519.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;将上式中的Camera坐标提到一边，带入基本矩阵解求对极同名点的方程，即可得到F的表达式.&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce7854f3d64.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;上式即为基础矩阵方程。其中，F是基础矩阵，x’x分别为同名点。而左右两个平面的两条极线为，显而易见，F由E和两个内参数矩阵决定。&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/26/56d06ae01c63d.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;类似的，F与E一样都能指同名点坐标在对应极线的关系。下图分别是已知左右点其对应极线的关系。&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce78b202e41.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;一个简单的例子，如果从某种方式计算出基础矩阵，则在对应图中即可表示出像素点对应的极线。&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/28/56d3bee0758a5.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;计算出矩阵即为l的三个参数。一般的，调整比例 将前两项的平方和定为1.&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/28/56d3bf4cbf895.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;findfundamentalmat()本意为基础矩阵，是假设两幅图像在同一三维场景中的不同视角。例如立体摄像机，从不同的角度拍摄同一个目标，它解算的是，两幅图像其中一个同名点，与其在外极线同名点的转换关系。它的映射基于三维场景，因此使用这个函数的时候，在不同的视角之间，应该有一个明显的基线。默认使用7点算法拟合数据。基础矩阵把左边图像的一个点的图像坐标与它右边图像中的对应点的图像联系起来，他是一个3x3的退化矩阵，描述了两个立体图像对的外极限几何关系，其计算依赖于在两个图像中相对应的一组点。&lt;/p&gt;
&lt;p&gt;与Homography矩阵（下文提到）不同，它在每组对应点有两组约束：x、y同时作为x’y’的自变量，估算一组对应点只有一行的约束，因为极线约束是标量等式。因此至少需要8个点。所以一般使用8点算法计算F矩阵(8点算法)。&lt;/p&gt;
&lt;p&gt;$$\begin{bmatrix} x^{‘}_i &amp;amp; y^{‘}_i &amp;amp; 1 \end{bmatrix} \begin{bmatrix} f_{11} &amp;amp; f_{12} &amp;amp; f_{13} \\\ f_{21} &amp;amp; f_{22} &amp;amp; f_{23} \\\  f_{31} &amp;amp; f_{32}  &amp;amp; f_{33}  \end{bmatrix} \begin{bmatrix} x_i \\\ y_i \\\ 1 \end{bmatrix}=0$$&lt;/p&gt;
&lt;p&gt;可推到出方程：&lt;/p&gt;
&lt;p&gt;$$ x_i x^{‘}_i f_{11} + x_i y^{‘}_i f_{21} + x_i f_{31} + y_i x^{‘}_i f_{12} + y_i y^{‘}_i f_{22} + y_i f_{32} + {x_i}^{‘} f_{13} + y^{‘}_i f_{23} + f_{33} =0$$&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/02/29/56d3ed9679e76.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;最终目标是找到ATA的一个特征向量使得它的特征值最小。常用的解法是构造m*9的矩阵A（m是点对数），求解A的奇异值分解，即A=UDVT，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;U是m*m正交矩阵，其列为AAT特征向量&lt;/p&gt;
&lt;p&gt;V是m*n正交阵，其列为ATA的特征向量&lt;/p&gt;
&lt;p&gt;D是m*n对角阵，对角元素为奇异值，平方值为AAT和ATA的特征值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而F是由7个自由度构成的3*3矩阵，其秩为2，因此，讲道理，9个表达式由7个参数构成，因此只用7对对应点理应也能解算出F矩阵（7点算法）。使用此方法计算F矩阵时，需要加上秩为2的限制，以保证计算结果唯一。该方法亦叫做奇异约束。该约束限制假设以F’替代F矩阵，计算时以&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%99%A3%E7%AF%84%E6%95%B8#.E5.BC.97.E7.BD.97.E8.B4.9D.E5.B0.BC.E4.B9.8C.E6.96.AF.E7.AF.84.E6.95.B0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;F范式&lt;/a&gt;作为标准。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/03/29/56fb45459399e.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;其中，$\sigma$是M矩阵的奇异值（A*·A的n个特征值的非负平方根叫作A的奇异值），M=F-F’,可以通过SVD分解解出该奇异值。&lt;br&gt;&lt;br&gt;&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/03/29/56fb506cb6765.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;F由于秩为2的限制可以以以下形式表示：&lt;/p&gt;
&lt;p&gt;F=αF1+(1-α)F2.其中，F1和F2分别Fx=0的两个解。&lt;/p&gt;
&lt;p&gt;由于秩=2，因此det(F=αF1+(1-α)F2)=0,通过该式即可求出α的值。&lt;/p&gt;
&lt;p&gt;更多内容可以看计算机视觉Trifocal tensor三角点张量的部分。&lt;/p&gt;
&lt;p&gt;Caution!&lt;/p&gt;
&lt;p&gt;对图像进行匹配的一个重要步骤就是把两幅图像的极线平行于基线，使得极点处在正无穷，这样的拼接结果效果才能更好。这一重要步骤即为重投影。如下图将黑线投影为蓝线。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/02/29/56d3f1e8a7005.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;对图像进行矫正。需要一个单映矩阵，作两步旋转。其第一步是将极点旋转到无穷远，第二部是将极线平行。其中，左右图像均需要应用该单映聚阵R将极点无穷远化；而右图像需要应用旋转矩阵（E=RS中的R）。最后比例一致化。&lt;/p&gt;
&lt;p&gt;上文中需要构造的矫正矩阵形式为：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/02/29/56d3f5a8ace5f.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;T是单位矩阵，代表左图的极点，可由E计算。其余的参数：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/02/29/56d3f66d34abd.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;整理一下步骤即为：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/29/56d3f7afcf9ce.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;下图即为矫正的例子（两幅图的变化很小，但是从边缘还是可以看到细微的变化），最后把图像的极点都化为无穷远，两幅图基于基线平行。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/29/56d3f7745f920.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;hr&gt;
&lt;h1 id=&quot;第二个矩阵-Homography（单映）矩阵&quot;&gt;&lt;a href=&quot;#第二个矩阵-Homography（单映）矩阵&quot; class=&quot;headerlink&quot; title=&quot;  第二个矩阵 Homography（单映）矩阵&quot;&gt;&lt;/a&gt;&lt;strong&gt;  第二个矩阵 Homography（单映）矩阵&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;findhomography的前提是2D的转换，本意为单映（包含平移、仿射、尺度三种变换），试图找到一个3*3的投影矩阵，能够把1图中所有的点，通过某种形变，匹配到2图中去。当基线很小的时候(视差变化小，扭曲形变也少)，这个方法能够计算出精度极高的解。&lt;br&gt;当然可以首先参考opencv的&lt;a href=&quot;http://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html?highlight=findhomography&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt; 这里首先介绍二维映射的单映（homography）矩阵&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/23/56a3baf462830.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;该式反应了像点齐次坐标的单映变换的方程。（u v）(u’ v’)分别是左右图像的同名像点坐标。通过一个8个自由度的矩阵P来解算两者之间的关系。p02 p12与平移相关，p00,p01,p10,p11与旋转 尺度和仿射（平行变换）变换有关，p20,p21与拉伸扭曲有关。&lt;/p&gt;
&lt;p&gt;一般的，单映矩阵的计算由以下几个参数构成&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/23/56a3bf63f1be0.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;其中，K是相机的内矩阵，由焦距决定；R是主光轴朝向，一般由3个方向余弦决定；C是摄影中心的物方位置。当在原地旋转时，C1-C2为0，因此方程可简化为&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/23/56a3c1dd3035a.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;由相机纯粹旋转而形成的单映，自由度3-5（根据是否已知焦距决定）。&lt;/p&gt;
&lt;p&gt;Caution！应该注意到的是，上式中的H3*3矩阵的最后一个元素为1。这里使用到的是计算H矩阵最常用的一种方法，4点算法，即使用4个点即可解算一组H中的8个未知数。在ransac验证外点的过程中，也采用随机4点为一组构建8个方程解算H。&lt;/p&gt;
&lt;p&gt;尽管homography是处理二维点集之间的关系，但倘若三维物体中某些点都处于一个平面，即可设该面的z方向值为0，以三维物方xy值作为像素值与所成像片进行homography的变换。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce6ba16113c.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;上图是几种坐标系之间的关系，Mext是外参数矩阵，包含旋转和平移；Mproj是投影矩阵，主要由焦距决定，原理是共线方程；Maff是内参数仿射变换矩阵，由内参数决定。普通的homography是两幅图像像素坐标间或相片坐标间的变换，但上文提到，当三维物体某些点处于一个平面，亦可在World坐标和Film坐标之间进行homography矩阵变换。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce6cd71fc88.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;上图可以看到，将三维坐标点z值设为0，[p,q,0,1]即为三维齐次坐标。&lt;/p&gt;
&lt;p&gt;$$ \begin{bmatrix} x\\\ y \\\ 1&lt;br&gt;\end{bmatrix} \sim \begin{bmatrix} f &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\ 0 &amp;amp; f &amp;amp; 0 &amp;amp; 0 \\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \end{bmatrix} \begin{bmatrix} r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\\ r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\\ r_{31} &amp;amp; r_{32}&amp;amp; r_33 &amp;amp; t_z \\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{bmatrix} \begin{bmatrix} p \\\ q \\\ 0\\\ 1 \end{bmatrix} \sim \begin{bmatrix} fr_{11} &amp;amp; fr_{12} &amp;amp; ft_x \\\ fr_{21} &amp;amp; fr_{22} &amp;amp; ft_y \\\ r_{31} &amp;amp; r_{32} &amp;amp; t_z \end{bmatrix} \begin{bmatrix} p \\\ q\\\ 1 \end{bmatrix}&lt;br&gt;$$$$\sim \begin{bmatrix} h_{11} &amp;amp; h_{12}&amp;amp;h_{13} \\\ h_{21} &amp;amp; h_{22} &amp;amp; h_{23} \\\ h_{31} &amp;amp; h_{32} &amp;amp; h_{33} \end{bmatrix} \begin{bmatrix} p \\\ q \\\ 1 \end{bmatrix}$$&lt;br&gt;最终推到出，3D转2D的投影变换成为2D转2D的变换，该变化可逆！其特例是，当采用的物方坐标系z轴与主光轴平行，即正射影像，则上式R矩阵为&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce7aab1b305.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;则上式变形为：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/24/56ce7b0376427.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;该式与相似变换的形式一样，只有4个自由度（tz可化为1），因而正射影像不会产生拉伸形变。（前提是拍摄物体几乎没有深度，几乎处在一个平面）。下图是依照三维中某平面进行拼接，会造成除平面部分其余图像的虚影。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf114fc872a.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf117891dbb.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;上文中一直讨论的是从物方坐标系到像片坐标系的转换，倘若再加上内方位参数的内矩阵，则可直接导出从物方坐标到像素坐标的公式，如下图示意。内方位参数为仿射变换（Affine 6自由度 保持平行结构的变换）&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56ceb1181fa03.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;将world-&amp;gt;film-&amp;gt;pixel结合起来，对于同一个物体，在某位置某台相机拍摄的照片就可以认为是一个单映H。当然，不同的位置拍摄的像片，各自对应物体的单映是不同的。但由于单映是可逆的，拍摄同一物体的两幅图像，也可以用使用$$H=H_{1}H_{2}^{-1}$$&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56ceb83e89a7b.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cebcef9abd7.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;hr&gt;
&lt;h1 id=&quot;Homography（单映）矩阵的求取&quot;&gt;&lt;a href=&quot;#Homography（单映）矩阵的求取&quot; class=&quot;headerlink&quot; title=&quot;  Homography（单映）矩阵的求取&quot;&gt;&lt;/a&gt;&lt;strong&gt;  Homography（单映）矩阵的求取&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;参考&lt;a href=&quot;http://www.robots.ox.ac.uk/~vgg/presentations/bmvc97/criminispaper/node3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;  只要大于4个匹配点，都认为是冗余测量，必须融合数据。文章里提到了三种解求二维面到面的单应矩阵的球法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非线性的解决办法，使用伪逆进行分解。当所解求值为0时会有bug。&lt;/li&gt;
&lt;li&gt;线性最小二乘解法，通常使用SVD分解，V矩阵就对应了最小奇异值。&lt;a href=&quot;http://blog.chinaunix.net/uid-20761674-id-4040274.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个SVD的文章&lt;/a&gt;相当好的解释了SVD分解的意义。八个未知数对应八个特征向量，也对应八个线性方程的解。SVD能直接解求出这八个向量，即V中的特征向量。&lt;/li&gt;
&lt;li&gt;非线性几何解法，使对应点和映射点差值欧几里得距离（或平方和）最小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Homograhy的计算：计算该矩阵当然不会上式f θ等值直接解算。由于是二维图像之间的关系，一般都已知二维对应点集，直接采用最小二乘的方式使用LM进行计算。在一般情况下的H矩阵可表示为&lt;/p&gt;
&lt;p&gt;$$ \begin{bmatrix} x^{‘} \\\ y^{‘} \\\ 1 \end{bmatrix} \sim \begin{bmatrix} h_{11} &amp;amp; h_{12} &amp;amp; h_{13} \\\ h_{21} &amp;amp; h_{22} &amp;amp; h_{23} \\\ h_{31} &amp;amp; h_{32} &amp;amp; h_{33} \end{bmatrix} \begin{bmatrix} x \\\ y \\\ 1 \end{bmatrix}$$&lt;/p&gt;
&lt;p&gt;其中，$h_{31} h_{32} h_{33}$是为了配置相似比例，化简为&lt;/p&gt;
&lt;p&gt;$$x^{‘}=\frac{h_{11} x + h_{12} y + h_{13} }{ h_{31} x + h_{32} y + h_{33} }$$&lt;/p&gt;
&lt;p&gt;$$y^{‘}=\frac{h_{21} \cdot x + h_{22} y + h_{23} }{ h_{31} x + h_{32} y + h_{33} }$$&lt;/p&gt;
&lt;p&gt;但可以看到，h所有元素同乘k 等式依旧成立。因而强制设为8自由度有两种方式，&lt;/p&gt;
&lt;p&gt;①$$ h_{33} = 1 $$&lt;/p&gt;
&lt;p&gt;②$$ h_{11}^{2} + h_{12}^{2} = 1 $$&lt;br&gt;采用第一种方式较为常见。&lt;br&gt;当采用最小二乘解求H矩阵时，一般先用Ransac筛选最大集，然后利用下方程。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf041a7c664.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;以x y x’y’为A b矩阵参数，迭代解求H。由于是线性方程，因而可以直接使用$$h=(A^{T}A)^{-1}(A^{T}b)$$求取每次的残差。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf051be79bc.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;&amp;lt;font color=”#ff0000”&amp;gt;Caution！应该注意到的是，该方法对噪声极其敏感，即使没有外点（outliers）,因而，在计算前对数据里筛选就非常重要。为更好的得到结果，Ransac时可以将该组数据质心重置到原点；然后缩放比例使得各点到原点的平均距离是根号二。如下图，H的表达式。T、S分别为平移和缩放的矩阵。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf08c613352.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;如何判断这两幅图像确实匹配呢？记该区域的特征点总数为nf，而符合H的特征点（内点）数量为nj，如果两者比例足够大，说明两幅图像确实匹配。但一般拼接时都确认两幅图像有重叠面积才计算H。变换模型H计算时的误差可表述为Huber模型：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf0b53675d9.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;同时，由于矩阵具有可逆性，因此图像12之间的H1和图像23之间的H2可以直接推导出图像13之间的H3。但大量的单映队列并不推荐，这样会造成误差成倍扩大。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/02/25/56cf0eb50a41b.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt; 谨记二 &lt;/strong&gt;：homography处理的是纯粹的二维与二维之间的变换。即便特例是3D也是视为在2D的单映和相似变换。在旋转相机和正射拼接可以得到良好的二维拼接效果，在具有深度的三维物体，拼接会造成虚影！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这两个函数都是基于特征点的变换模型求解，既然特征点已找出且筛查得到更正确的点，因此对图像外观的变化具有鲁棒性（尺度、光照、旋转等）。选择哪种函数基于图像间的关系，即立体场的观测使用fundamentalmatrix（视角矫正 三维全景 街景视角）,而相对平面化的则使用findhomography（全景拼接  航摄图像拼接 ）&lt;/p&gt;
&lt;p&gt;解求这个变换模型一般基于线性最小二乘的方式，与平差原理类似，利用冗余的数据（大量同名点）来解算参数。一般的，先通过Ransac筛查数据比较靠谱。&lt;/p&gt;
&lt;h1 id=&quot;谨记三：&quot;&gt;&lt;a href=&quot;#谨记三：&quot; class=&quot;headerlink&quot; title=&quot;** 谨记三：&quot;&gt;&lt;/a&gt;** 谨记三：&lt;/h1&gt;&lt;p&gt;homography 单映处理二维坐标系与二维坐标系关系，特例情况下是三维物体某平面可视为二维平面。更特例的是正射影像（相似变换）和旋转摄影全景拼接（C1-C2=0）（处理对应点集与点集的关系）矩阵可逆，具有结合性。&lt;/p&gt;
&lt;p&gt;fundamental针对的是点和极线的关系（处理点集与极线集的关系），可用来在寻找匹配点的时候快速查找对应点。（以像素为坐标系）&lt;/p&gt;
&lt;p&gt;essential 本质是连结同名点向量的矩阵（以像空系为标准）&lt;/p&gt;
&lt;p&gt;参考。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/u010141025/article/details/16920567&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【opencv】特征点检测方法–GFTT，SIFT，FAST，SURF&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cse.psu.edu/~rtc12/CSE486/&quot; title=&quot;http://www.cse.psu.edu/~rtc12/CSE486/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cse.psu.edu/~rtc12/CSE486/&lt;/a&gt; 宾州州立大学计算机视觉&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://opencv-users.1802565.n2.nabble.com/Difference-between-homography-and-fundamental-matrix-td6359087.html&quot; title=&quot;http://opencv-users.1802565.n2.nabble.com/Difference-between-homography-and-fundamental-matrix-td6359087.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://opencv-users.1802565.n2.nabble.com/Difference-between-homography-and-fundamental-matrix-td6359087.html&lt;/a&gt; homography and fundamental matrix的讨论&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://homepages.inf.ed.ac.uk/rbf/CVonline/&quot; title=&quot;http://homepages.inf.ed.ac.uk/rbf/CVonline/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://homepages.inf.ed.ac.uk/rbf/CVonline/&lt;/a&gt; 爱丁堡大学计算机视觉在线课件&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.robots.ox.ac.uk/~vgg/hzbook/hzbook2/HZepipolar.pdf&quot; title=&quot;https://www.robots.ox.ac.uk/~vgg/hzbook/hzbook2/HZepipolar.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.robots.ox.ac.uk/~vgg/hzbook/hzbook2/HZepipolar.pdf&lt;/a&gt; 牛津大学计算机视觉中的多视几何&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://120.52.72.36/www.umiacs.umd.edu/c3pr90ntcsf0/~ramani/cmsc828d/lecture27.pdf&quot; title=&quot;http://120.52.72.36/www.umiacs.umd.edu/c3pr90ntcsf0/~ramani/cmsc828d/lecture27.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://120.52.72.36/www.umiacs.umd.edu/c3pr90ntcsf0/~ramani/cmsc828d/lecture27.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;马里兰大学高级计算机研究&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/gemstone/articles/2294551.html&quot; title=&quot;http://www.cnblogs.com/gemstone/articles/2294551.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/gemstone/articles/2294551.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://imagine.enpc.fr/~monasse/Stereo/4Fundamental.pdf&quot; title=&quot;http://imagine.enpc.fr/~monasse/Stereo/4Fundamental.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://imagine.enpc.fr/~monasse/Stereo/4Fundamental.pdf&lt;/a&gt; 法国国立桥梁与公路学校Ecole Nationale des Ponts et Chaesses计算机视觉和图像&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;openCV中有两个函数，findhomography和findfundamentalmat，长的很像。。一开始严重的弄混，以为都是求对应点投影矩阵的公式，万万没想到其实是两个完全不同的内涵。😒&lt;br&gt;
    
    </summary>
    
      <category term="什么都学一下" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/"/>
    
      <category term="学习log" scheme="http://ovjaywang.github.io/categories/%E4%BB%80%E4%B9%88%E9%83%BD%E5%AD%A6%E4%B8%80%E4%B8%8B/%E5%AD%A6%E4%B9%A0log/"/>
    
    
      <category term="opencv" scheme="http://ovjaywang.github.io/tags/opencv/"/>
    
      <category term="计算机视觉" scheme="http://ovjaywang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>社交App的2015</title>
    <link href="http://ovjaywang.github.io/2016/01/18/%E7%A4%BE%E4%BA%A4app%E7%9A%842015/"/>
    <id>http://ovjaywang.github.io/2016/01/18/社交app的2015/</id>
    <published>2016-01-18T03:45:06.000Z</published>
    <updated>2016-04-28T17:43:27.000Z</updated>
    
    <content type="html">&lt;p&gt;手机和网络重度使用患者也该是总结自己的时候了。庆幸的是各大app都热推了自己的2015数据流。把去年的数据库做个直白的excel统计。好吧。。我除了听歌看电影买买买也没别的(性)生活了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b74dab78e7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;进入微信还算比较早的。和我的两个基友都是300w内。但是潜水了快3年才在快毕业的时候旅行发了一条盆友圈。曾一度抗拒盆友圈这个类似空间的东西。当然大学的社交网络还是集中在“找人人上同学”的人人网。。毕竟各大校园通知新闻、文娱八卦、技术贴以及各种曾在校园见过又不知道是谁的人终于知道叫什么名字了。。还曾一度影响了各类插件的发展、影响了谁来看过我我被多少人看过的各类访问人数的截图。。现在看来。。大家当年都是一个水平的嘛&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b765a8c8ed.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;快一年也没旅游了。说是没时间不如说是没人陪。。只有寒假去东三省和海南度假算是正经的轻松了一回。不过上海的cj也是满满的收获。。红包多是借钱还钱。。。才没有人给我发红包呢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b76c34f72d.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;惨淡的人际网并不像急于拓展。收货了太多的信息来源反倒不如维护好几个重要的人。。还未曾到需要攀龙附凤的阶段。充实自己吧。用了一段时间的手环终究是没有逃过不出一年就坏掉的命运。。所以微信运动总是几百米的步数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b8cd37fbf6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实点口碑外卖并不多。。不知道它计算了别的外卖支付没有。。。想想也就吃了下半年则么会这么多。。或许是把优惠支付也算进去了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b8d469df74.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了一个月试了试微信的信用卡还款基本都在支付宝还款了。。后面几个月已经扒不到网易邮箱的信用卡账单了。。每次都要手动输金额也是好烦。。生产力还没达到一定程度消费就花了这么多了。。手机充值的方式越来越多样化。总之和外卖 电影一样 谁便宜去谁家。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b8dfc35999.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;大部分能用华北的地方都没主动用。。第一推荐的基本没人会主动换掉。。港真。芝麻信用分还是挺有用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b92b0b7ced.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;常年有1w余额。。这年利率越来越低了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b9351c9783.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;大多数买买买都是电子产品。。两个手机。两个耳机。。单反。。品质的一年。旅游真的变少了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b99e34fd85.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;比格这么高的音乐软件入碗了入碗了！！毕竟还是个网易最早用户呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b9a1dc8bf6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上班听歌狗。。。没歌没效率的最佳代言人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b9a48e60dc.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;真是李荣浩狗。。陈粒狗。。李志狗。。还是国语歌听的比较顺耳&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b9a7cebaa4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;喂喂喂！！要你管啦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569b9a99a92ea.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;是的！都怪你拉！&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c588aa63d8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;也是由于从村里搬到了城里。本以为8.8的电影算是捡了大便宜。妹想到4块钱看了个星战。闲来无事，也只能有看电影能消遣了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569c5ae2d384a.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;也是被自己的频率吓到。。毕竟前半个年基本没有机会看到电影院。。。或许是回忆标记的电影略多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c587a5e523.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;电影院基本四星以下。唯独记得的几部看的相当爽的只有【师傅】【暗杀】【心迷宫】其他的五星基本在补电影。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c58890e21e.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;毕竟是互联网社交的先驱。极客的事业之道&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c588ab1ec6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;港真。自尊心在受到歧视的人群更显得珍重。民族歧视、种族歧视、地域歧视，如果解决不好，就不是花钱能够应付的了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c588c1f10b.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一次对动画电影这么赞叹，不愧是日本的高分动画。不愧是宫崎骏老师的配乐&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c5897d8f92.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;好吧。。容我矫情一回好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/01/17/569c588d50b2d.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;也不知道寒假怎么了。应该是约约约才对的阿。三月四月完全没有流量下电影。。也无心恋战。沉迷健身、跑步、羽毛球、课设、、、&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569c5c4cdd158.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;豆瓣电影和豆瓣app相当混淆。。不知道应该取舍哪一个&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ooo.0o0.ooo/2016/01/17/569c5c7918c03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       &amp;amp;lt;p&amp;amp;gt;果然是2月挖坟了过往的很多电影。。毕竟也是太闲了这样算下来和前一年看的就差不多了&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;&amp;amp;lt;img src=&amp;quot;http://ooo.0o0.ooo/2016/01/17/569c5cba269c4.png&amp;quot;&amp;amp;gt;&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;&amp;amp;lt;img src=&amp;quot;http://ooo.0o0.ooo/2016/01/17/569c5cf85db53.png&amp;quot;&amp;amp;gt;&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;虽然口味较重。但类型没有特别偏颇的。反倒是对美帝的电影相当喜爱。&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;&amp;amp;lt;img src=&amp;quot;http://ooo.0o0.ooo/2016/01/17/569c5d1f44a7d.png&amp;quot;&amp;amp;gt;&amp;amp;lt;/p&amp;amp;gt;    &amp;amp;lt;p&amp;amp;gt;虽然很爱大咪咪。但演的渣还是不能同情的。。虽然艾玛斯通对你国态度相当恶劣。但演得好还是要乖乖献出5分。&amp;amp;lt;img src=&amp;quot;http://ooo.0o0.ooo/2016/01/17/569c5d7f7dbe0.png&amp;quot;&amp;amp;gt;&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;第一部是欠的电影票。。第二部是第一次看到了电影院娇嗔的妹子。。第三部是18.8看了个imax。。我是奇葩恩恩我承认好了&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;&amp;amp;lt;img src=&amp;quot;http://ooo.0o0.ooo/2016/01/17/569c5dc6997cf.png&amp;quot;&amp;amp;gt;&amp;amp;lt;/p&amp;amp;gt; &amp;amp;lt;p&amp;amp;gt;港真。。特工学院这剧情和特效能看？还有那操蛋的英伦腔。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;手机和网络重度使用患者也该是总结自己的时候了。庆幸的是各大app都热推了自己的2015数据流。把去年的数据库做个直白的excel统计。好吧。。我除了听歌看电影买买买也没别的(性)生活了。&lt;br&gt;
    
    </summary>
    
      <category term="槽" scheme="http://ovjaywang.github.io/categories/%E6%A7%BD/"/>
    
    
  </entry>
  
</feed>
